!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AFLAGS	Makefile	/^AFLAGS := -cvr$/;"	m
ALIGN	commonn/memCache.h	/^enum {ALIGN = 64};$/;"	e	enum:__anon3
AR	Makefile	/^AR := ar$/;"	m
AddTask	commonn/ThreadPool.cpp	/^int CThreadPool::AddTask(CTask* pTask)$/;"	f	class:CThreadPool
Allocate	commonn/memCache.h	/^class Allocate$/;"	c
BUFLEN	test/case/getline/server_simple.cpp	15;"	d	file:
BUFLEN	test/case/getn/server_simple.cpp	15;"	d	file:
BUFLEN	test/server_simple.cpp	15;"	d	file:
BUSY	rapool.cpp	/^    BUSY$/;"	e	enum:__anon8	file:
BUSY	sapool.cpp	/^    BUSY$/;"	e	enum:__anon13	file:
Buffer	Buffer.h	/^        Buffer(Buffer & bf)$/;"	f	class:Buffer
Buffer	Buffer.h	/^        explicit Buffer() : cache(NULL),$/;"	f	class:Buffer
Buffer	Buffer.h	/^        explicit Buffer(int size)$/;"	f	class:Buffer
Buffer	Buffer.h	/^class Buffer$/;"	c
CFLAGS	Makefile	/^CFLAGS := -g -c -Wall$/;"	m
CHUNK_NODE	commonn/memCache.h	/^enum {CHUNK_NODE = 20};$/;"	e	enum:__anon6
COMMON_DIR	Makefile	/^COMMON_DIR := .\/commonn$/;"	m
COM_OBJS	Makefile	/^COM_OBJS := timer.o queue.o memCache.o asynLog.o$/;"	m
CTask	commonn/ThreadPool.h	/^        CTask()$/;"	f	class:CTask
CTask	commonn/ThreadPool.h	/^class CTask $/;"	c
CThreadNotify	commonn/ThreadPool.cpp	/^CThreadNotify :: CThreadNotify()$/;"	f	class:CThreadNotify
CThreadNotify	commonn/ThreadPool.h	/^class CThreadNotify$/;"	c
CThreadPool	commonn/ThreadPool.cpp	/^CThreadPool::CThreadPool()$/;"	f	class:CThreadPool
CThreadPool	commonn/ThreadPool.h	/^class CThreadPool $/;"	c
CWorkerThread	commonn/ThreadPool.cpp	/^CWorkerThread::CWorkerThread()$/;"	f	class:CWorkerThread
CWorkerThread	commonn/ThreadPool.h	/^class CWorkerThread $/;"	c
CXX	Makefile	/^CXX := g++$/;"	m
ConfigParser	commonn/configParser.h	/^        ConfigParser(){}$/;"	f	class:ConfigParser
ConfigParser	commonn/configParser.h	/^class ConfigParser$/;"	c
DEBUG	commonn/asynLog.cpp	/^Log :: DEBUG(const char * fmt, ...)$/;"	f	class:Log
DEFAULT_CHECK_INTERVAL	sapool.cpp	/^    DEFAULT_CHECK_INTERVAL = 10,  \/\/\/Ä¬ÈÏcheck_interval, 10ms$/;"	e	enum:__anon12	file:
DEFAULT_QUEUE_LEN	sapool.cpp	/^    DEFAULT_QUEUE_LEN = 100,      \/\/\/Ä¬ÈÏµÄµÈ´ý¶ÓÁÐµÄ³¤¶È 100$/;"	e	enum:__anon12	file:
DEFAULT_SOCK_NUM	sapool.cpp	/^    DEFAULT_SOCK_NUM = 500,       \/\/\/Í¬Ê±Î¬»¤µÄ×î´ósock¾ä±úÊý£¬500$/;"	e	enum:__anon12	file:
DEFAULT_TIMEOUT	sapool.cpp	/^    DEFAULT_TIMEOUT = 60000,         \/\/\/µÈ´ý¶ÓÁÐÀïÃæµÄÄ¬ÈÏ³¬Ê±Ê±¼ät, 60s$/;"	e	enum:__anon12	file:
DELETED	Buffer.h	/^static const bool DELETED = true;$/;"	v
Destory	commonn/ThreadPool.cpp	/^void CThreadPool::Destory()$/;"	f	class:CThreadPool
EPOLL_ACTIVED	util.h	26;"	d
EPOLL_UNACTIVED	util.h	27;"	d
ERROR	commonn/asynLog.cpp	/^Log :: ERROR(const char * fmt, ...)$/;"	f	class:Log
EV_ACTIVE	util.h	14;"	d
EV_INIT	util.h	12;"	d
EV_INSERTED	util.h	13;"	d
EV_ONCE	util.h	20;"	d
EV_PERSIST	util.h	10;"	d
EV_READ	util.h	8;"	d
EV_READUNFIN	util.h	15;"	d
EV_THREAD	util.h	19;"	d
EV_TIMEOUT	util.h	7;"	d
EV_WRITE	util.h	9;"	d
EV_WRITEUNFIN	util.h	16;"	d
EXECUTE	Makefile	/^EXECUTE := $(TAR_OBJ)$/;"	m
Event	event.h	/^        Event(Event & ev)$/;"	f	class:Event
Event	event.h	/^    explicit Event() : ev_fd(0),$/;"	f	class:Event
Event	event.h	/^class Event$/;"	c
EventTask	event.h	/^        EventTask() : ev_task(NULL)$/;"	f	class:EventTask
EventTask	event.h	/^        EventTask(Event * ev) : ev_task(ev)$/;"	f	class:EventTask
EventTask	event.h	/^class EventTask : public CTask$/;"	c
Execute	commonn/ThreadPool.cpp	/^void CWorkerThread::Execute()$/;"	f	class:CWorkerThread
FD_ACTIVE	util.h	24;"	d
FD_NOSLEEP	util.h	23;"	d
FREELIST_INDEX	commonn/memCache.h	/^    static size_t FREELIST_INDEX(size_t n)$/;"	f	class:Allocate
FRESHLIMIT	Buffer.h	/^static const bool FRESHLIMIT = 1024;$/;"	v
FRESHLIMIT	Buffer.h	/^static const bool FRESHLIMIT = 8;$/;"	v
Factory	factory.h	/^        Factory(const std::string  & conf)$/;"	f	class:Factory
Factory	factory.h	/^class Factory$/;"	c
GetThreadIdx	commonn/ThreadPool.h	/^        int GetThreadIdx() $/;"	f	class:CWorkerThread
GetWorkerBuff	commonn/ThreadPool.h	/^        void * GetWorkerBuff()$/;"	f	class:CWorkerThread
GetWorkerLen	commonn/ThreadPool.h	/^        int GetWorkerLen()$/;"	f	class:CWorkerThread
IDLE	rapool.cpp	/^    IDLE = 0,$/;"	e	enum:__anon8	file:
IDLE	sapool.cpp	/^    IDLE = 0,$/;"	e	enum:__anon13	file:
INIT	nf_server_core.h	/^    INIT    = 0,$/;"	e	enum:__anon9
LEVEL	commonn/asynLog.cpp	/^int Log :: LEVEL = LOG_DEBUG;$/;"	m	class:Log	file:
LEVEL	commonn/asynLog.h	/^    static int LEVEL;$/;"	m	class:Log
LISTENER_PRIORITY	rapool.h	20;"	d
LISTENER_PRIORITY	sapool.h	26;"	d
LISTS	commonn/memCache.h	/^enum {LISTS = MAX_BYTES\/ALIGN};$/;"	e	enum:__anon5
LOG_DEBUG	commonn/asynLog.h	/^    LOG_DEBUG,$/;"	e	enum:__anon1
LOG_ERROR	commonn/asynLog.h	/^    LOG_ERROR,$/;"	e	enum:__anon1
LOG_INIT	commonn/asynLog.h	/^    LOG_INIT,$/;"	e	enum:__anon2
LOG_MAXLINE	commonn/asynLog.h	/^    LOG_MAXLINE = 6000$/;"	e	enum:__anon1
LOG_NOTICE	commonn/asynLog.h	/^    LOG_NOTICE,$/;"	e	enum:__anon1
LOG_RUN	commonn/asynLog.h	/^    LOG_RUN,$/;"	e	enum:__anon2
LOG_STOP	commonn/asynLog.h	/^    LOG_STOP$/;"	e	enum:__anon2
LOG_WARN	commonn/asynLog.h	/^    LOG_WARN, $/;"	e	enum:__anon1
LfServer	lfpool.h	/^        LfServer(){};$/;"	f	class:LfServer
LfServer	lfpool.h	/^class LfServer : public NfServer$/;"	c
Lock	commonn/ThreadPool.h	/^	void Lock() $/;"	f	class:CThreadNotify
Lock	commonn/singleton.h	/^        static MutexLock Lock;$/;"	m	class:Singleton
Lock	commonn/singleton.h	/^MutexLock Singleton<T>::Lock;$/;"	m	class:Singleton
Log	commonn/asynLog.h	/^class Log$/;"	c
MAX	rapool.cpp	16;"	d	file:
MAX	sapool.cpp	18;"	d	file:
MAX_BYTES	commonn/memCache.h	/^enum {MAX_BYTES = 1024};$/;"	e	enum:__anon4
MutexLock	commonn/singleton.h	/^        MutexLock()$/;"	f	class:MutexLock
MutexLock	commonn/singleton.h	/^class MutexLock$/;"	c
NFSVR_LONG_CONNEC	nf_server_core.h	/^    NFSVR_LONG_CONNEC$/;"	e	enum:__anon11
NFSVR_POOL_NUM	nf_server_core.h	/^    NFSVR_POOL_NUM,     \/\/µ±Ç°ÓÐ¶àÉÙ¸öpool    $/;"	e	enum:__anon10
NFSVR_RAPOOL	nf_server_core.h	/^    NFSVR_RAPOOL,        \/\/reactor + pthread IOÃÜ¼¯£¬thread ÊýÓëºËÓÐ¹Ø$/;"	e	enum:__anon10
NFSVR_SAPOOL	nf_server_core.h	/^    NFSVR_SAPOOL,        \/\/½¨ÒéÓÃÓÚ¶àÏß³Ì³¤Á¬½Ó     $/;"	e	enum:__anon10
NFSVR_SHORT_CONNEC	nf_server_core.h	/^    NFSVR_SHORT_CONNEC = 0,$/;"	e	enum:__anon11
NOTICE	commonn/asynLog.cpp	/^Log :: NOTICE(const char * fmt, ...)$/;"	f	class:Log
NfReactor	nf_server_core.h	/^        NfReactor() : Reactor()$/;"	f	class:NfReactor
NfReactor	nf_server_core.h	/^class NfReactor : public Reactor$/;"	c
NfServer	nf_server.cpp	/^NfServer :: NfServer()$/;"	f	class:NfServer
NfServer	nf_server.h	/^class NfServer$/;"	c
NonBlockFun	nf_base_work.h	/^    NonBlockFun(){}$/;"	f	class:NonBlockFun
NonBlockFun	nf_base_work.h	/^class NonBlockFun$/;"	c
NonBlockReadLine	nf_base_work.h	/^    NonBlockReadLine(){}$/;"	f	class:NonBlockReadLine
NonBlockReadLine	nf_base_work.h	/^    NonBlockReadLine(){}$/;"	f	class:NonBlockWrite
NonBlockReadLine	nf_base_work.h	/^class NonBlockReadLine : public NonBlockFun$/;"	c
NonBlockWrite	nf_base_work.h	/^class NonBlockWrite : public NonBlockFun$/;"	c
OBJS	Makefile	/^OBJS := net.o nf_server.o rapool.o timer.o nf_server_core.o \\$/;"	m
PAUSE	nf_server_core.h	/^    PAUSE   = 2,$/;"	e	enum:__anon9
PushTask	commonn/ThreadPool.cpp	/^void CWorkerThread::PushTask(CTask* pTask)$/;"	f	class:CWorkerThread
RA_CHECK_INTERVAL	rapool.cpp	/^    RA_CHECK_INTERVAL = 10,  \/\/\/Ä¬ÈÏcheck_interval, 10ms$/;"	e	enum:__anon7	file:
RA_SOCK_NUM	rapool.cpp	/^    RA_SOCK_NUM = 500,       \/\/\/Í¬Ê±Î¬»¤µÄ×î´ósock¾ä±úÊý£¬500$/;"	e	enum:__anon7	file:
RA_TIMEOUT	rapool.cpp	/^    RA_TIMEOUT = 60,         \/\/\/µÈ´ý¶ÓÁÐÀïÃæµÄÄ¬ÈÏ³¬Ê±Ê±¼ät, 60s$/;"	e	enum:__anon7	file:
READY	sapool.cpp	/^    READY,$/;"	e	enum:__anon13	file:
ROUND_UP	commonn/memCache.h	/^    static size_t ROUND_UP(size_t n)$/;"	f	class:Allocate
RUNNING	nf_server_core.h	/^    RUNNING = 1,$/;"	e	enum:__anon9
RaServer	rapool.h	/^        RaServer(){};$/;"	f	class:RaServer
RaServer	rapool.h	/^class RaServer : public NfServer$/;"	c
Reactor	reactor.h	/^        Reactor() : event_count(0),$/;"	f	class:Reactor
Reactor	reactor.h	/^class Reactor$/;"	c
ReadEvent	event.h	/^        explicit ReadEvent() : Event()$/;"	f	class:ReadEvent
ReadEvent	event.h	/^        explicit ReadEvent(int len) : Event()$/;"	f	class:ReadEvent
ReadEvent	event.h	/^class ReadEvent : public Event$/;"	c
SERVER_STATUS_T	nf_server_core.h	/^}SERVER_STATUS_T;$/;"	t	typeref:enum:__anon9
STATUS	commonn/asynLog.cpp	/^int Log :: STATUS = LOG_INIT;$/;"	m	class:Log	file:
STATUS	commonn/asynLog.h	/^    static int STATUS;   $/;"	m	class:Log
STOP	nf_server_core.h	/^    STOP    = 3$/;"	e	enum:__anon9
SVR_OBJS	Makefile	/^SVR_OBJS := net.o nf_server.o rapool.o nf_server_core.o \\$/;"	m
SaListenEvent	sapool.h	/^    explicit SaListenEvent() : Event()$/;"	f	class:SaListenEvent
SaListenEvent	sapool.h	/^class SaListenEvent : public Event$/;"	c
SaServer	sapool.h	/^        SaServer() : NfServer()$/;"	f	class:SaServer
SaServer	sapool.h	/^class SaServer : public NfServer$/;"	c
Section	commonn/configParser.h	/^class Section$/;"	c
Server	commonn/Server.h	/^        Server(){};$/;"	f	class:Server
Server	commonn/Server.h	/^class Server$/;"	c
SetBuff	commonn/ThreadPool.h	/^        void SetBuff(int size)$/;"	f	class:CWorkerThread
SetThreadIdx	commonn/ThreadPool.h	/^	    void SetThreadIdx(int idx) $/;"	f	class:CWorkerThread
Signal	commonn/ThreadPool.h	/^	void Signal() $/;"	f	class:CThreadNotify
Singleton	commonn/singleton.h	/^class Singleton$/;"	c
Start	commonn/ThreadPool.cpp	/^void CWorkerThread::Start()$/;"	f	class:CWorkerThread
StartRoutine	commonn/ThreadPool.cpp	/^void* CWorkerThread::StartRoutine(void* arg)$/;"	f	class:CWorkerThread
TAR_DIR	Makefile	/^TAR_DIR := .\/$/;"	m
TAR_OBJ	Makefile	/^TAR_OBJ := lib_nf_svr.a$/;"	m
THREAD	Makefile	/^THREAD := -lpthread$/;"	m
ThreadExcute	event.h	/^    static void * ThreadExcute(Event * arg)$/;"	f	class:Event
Timer	commonn/timer.h	/^class Timer$/;"	c
UNDELETED	Buffer.h	/^static const bool UNDELETED = false;$/;"	v
Unlock	commonn/ThreadPool.h	/^	void Unlock() $/;"	f	class:CThreadNotify
WARN	commonn/asynLog.cpp	/^Log :: WARN(const char * fmt, ...)$/;"	f	class:Log
WORK	util.h	5;"	d
WORKER_PRIORITY	rapool.h	21;"	d
WORKER_PRIORITY	sapool.h	27;"	d
Wait	commonn/ThreadPool.h	/^	void Wait() $/;"	f	class:CThreadNotify
WriteEvent	event.h	/^        explicit WriteEvent() : Event()$/;"	f	class:WriteEvent
WriteEvent	event.h	/^        explicit WriteEvent(int len) : Event()$/;"	f	class:WriteEvent
WriteEvent	event.h	/^class WriteEvent : public Event$/;"	c
_ASYN_LOG_	commonn/asynLog.h	13;"	d
_BUFFER_	Buffer.h	2;"	d
_CONFIG_PARSER_H	commonn/configParser.h	14;"	d
_EVENT_	event.h	2;"	d
_Lf_SERVER_H	lfpool.h	2;"	d
_MEM_CACHE_	commonn/memCache.h	13;"	d
_NFSERVER_CORE_H	nf_server_core.h	15;"	d
_NF_SERVER_H	nf_server.h	12;"	d
_PARSE_WORK_	nf_base_work.h	2;"	d
_QUEUE_H	commonn/queue.h	12;"	d
_REACTOR_	reactor.h	2;"	d
_SERVER_H	commonn/Server.h	9;"	d
_THREAD_POOL_H_	commonn/ThreadPool.h	2;"	d
_TIMER_	commonn/timer.h	14;"	d
_UTIL_	util.h	2;"	d
__NET_H__	net.h	12;"	d
__RAPOOL_H_	rapool.h	14;"	d
__SAPOOL_H_	sapool.h	20;"	d
_initialized	commonn/singleton.h	/^        static bool _initialized;$/;"	m	class:Singleton
_initialized	commonn/singleton.h	/^bool Singleton<T>::_initialized = false;$/;"	m	class:Singleton
_instance	commonn/singleton.h	/^        static T * _instance;$/;"	m	class:Singleton
_instance	commonn/singleton.h	/^T * Singleton<T>::_instance = NULL;$/;"	m	class:Singleton
_lfpool_t	lfpool.h	/^typedef struct _lfpool_t $/;"	s
_nf_server_pdata_t	nf_server_core.h	/^struct _nf_server_pdata_t$/;"	s
_nf_server_t	nf_server_core.h	/^struct _nf_server_t$/;"	s
_queue_t	commonn/queue.h	/^struct _queue_t$/;"	s
_rapool_sock_item_t	rapool.h	/^struct _rapool_sock_item_t$/;"	s
_rapool_t	rapool.h	/^typedef struct _rapool_t$/;"	s
_rio_t	net.h	/^typedef struct _rio_t$/;"	s
_singleton_h	commonn/singleton.h	13;"	d
add_buffer	event.h	/^    inline int add_buffer(void * tmp,$/;"	f	class:ReadEvent
add_buffer	event.h	/^    inline int add_buffer(void * tmp,$/;"	f	class:WriteEvent
add_data	Buffer.cpp	/^int Buffer :: add_data(void * tmp,$/;"	f	class:Buffer
add_ev_flags	event.h	/^    inline void add_ev_flags(int flg)$/;"	f	class:Event
add_event	reactor.cpp	/^int Reactor :: add_event(Event * ev,$/;"	f	class:Reactor
add_handl_num	Buffer.cpp	/^int Buffer :: add_handl_num(int handled)$/;"	f	class:Buffer
add_prefix	commonn/asynLog.cpp	/^add_prefix(char * dest, const string &add)$/;"	f
add_timer_ms	commonn/timer.cpp	/^Timer :: add_timer_ms(long long time, $/;"	f	class:Timer
addr	rapool.h	/^    struct sockaddr_in addr;$/;"	m	struct:_rapool_sock_item_t	typeref:struct:_rapool_sock_item_t::sockaddr_in
allo_len	Buffer.h	/^        int allo_len;$/;"	m	class:Buffer
allocate	commonn/memCache.cpp	/^Allocate :: allocate(size_t n)$/;"	f	class:Allocate
array	commonn/queue.h	/^    int *array;$/;"	m	struct:_queue_t
backlog	nf_server_core.h	/^    size_t backlog;$/;"	m	struct:_nf_server_t
buff_size	reactor.h	/^    int buff_size;$/;"	m	struct:threadParas
buffer	commonn/asynLog.cpp	/^char Log :: buffer[LOG_MAXLINE];$/;"	m	class:Log	file:
buffer	commonn/asynLog.h	/^    static char buffer[LOG_MAXLINE];$/;"	m	class:Log
cache	Buffer.h	/^        void * cache;$/;"	m	class:Buffer
cache	event.h	/^        Buffer  cache;$/;"	m	class:WriteEvent
cache	event.h	/^        Buffer cache;$/;"	m	class:ReadEvent
cache	net.h	/^    char * cache;$/;"	m	struct:_rio_t
cache_len	net.h	/^    int cache_len;$/;"	m	struct:_rio_t
call_back_timeout	rapool.cpp	/^RaServer :: call_back_timeout(void * param)$/;"	f	class:RaServer
cap	commonn/queue.h	/^    int cap;$/;"	m	struct:_queue_t
check_interval	rapool.h	/^    int check_interval;    \/\/Î¢Ãî¼¶±ðÖ§³Ö³¬Ê±$/;"	m	struct:_rapool_t
clear	Buffer.cpp	/^void Buffer :: clear()$/;"	f	class:Buffer
client_addr	nf_server_core.h	/^    struct sockaddr_in client_addr;$/;"	m	struct:_nf_server_pdata_t	typeref:struct:_nf_server_pdata_t::sockaddr_in
client_data	commonn/memCache.h	/^        char client_data[1];$/;"	m	union:Allocate::obj
connect_to	nf_server_core.h	/^    size_t connect_to;$/;"	m	struct:_nf_server_t
connect_type	nf_server_core.h	/^    size_t connect_type; $/;"	m	struct:_nf_server_t
createData	test/case/getline/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
createData	test/case/getn/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
createData	test/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
create_key_once	commonn/ThreadPool.cpp	/^create_key_once(void)$/;"	f
create_q	commonn/queue.cpp	/^int create_q(queue_t *q, int qcap)$/;"	f
create_svr	factory.h	/^    NfServer * create_svr()$/;"	f	class:Factory
ctime	commonn/asynLog.cpp	/^ctime(char * t_time, size_t n)$/;"	f
deallocate	commonn/memCache.cpp	/^Allocate :: deallocate(void * p, size_t n)$/;"	f	class:Allocate
default_hand	net.cpp	/^default_hand(int sig)$/;"	f
default_handle	test/server_simple.cpp	/^default_handle()$/;"	f
del_ev_flags	event.h	/^    inline void del_ev_flags(int flg)$/;"	f	class:Event
del_timer_ms	commonn/timer.cpp	/^Timer :: del_timer_ms(long long time, const void * const param)$/;"	f	class:Timer
destroy	commonn/singleton.h	/^        static void destroy()$/;"	f	class:Singleton
destroy_q	commonn/queue.cpp	/^int destroy_q(queue_t *q)$/;"	f
empty_q	commonn/queue.cpp	/^int empty_q(queue_t *q)$/;"	f
empty_str	commonn/configParser.cpp	/^static const std::string empty_str = "";$/;"	v	file:
end_idx	Buffer.h	/^        int end_idx;$/;"	m	class:Buffer
ep_events	rapool.h	/^    struct epoll_event * ep_events;$/;"	m	struct:_rapool_t	typeref:struct:_rapool_t::epoll_event
epfd	rapool.h	/^    int epfd;$/;"	m	struct:_rapool_t
epfd	reactor.h	/^        int epfd;$/;"	m	class:Reactor
epoll_add_event	reactor.cpp	/^int Reactor :: epoll_add_event(Event * ev, $/;"	f	class:Reactor
epoll_dispatch	reactor.cpp	/^int Reactor :: epoll_dispatch(int status,$/;"	f	class:Reactor
ev_active	event.h	/^        int ev_active;$/;"	m	class:Event
ev_arg	event.h	/^        void *ev_arg;$/;"	m	class:Event
ev_callback	event.h	/^        ev_handle ev_callback;$/;"	m	class:Event
ev_events	event.h	/^        short ev_events;$/;"	m	class:Event
ev_fd	event.h	/^        int ev_fd;$/;"	m	class:Event
ev_flags	event.h	/^        int ev_flags;$/;"	m	class:Event
ev_handle	event.h	/^typedef void (*ev_handle)(int, short, void *);$/;"	t
ev_list	reactor.h	/^        list<Event *> ev_list;$/;"	m	class:Reactor
ev_parse	event.h	/^        NonBlockFun * ev_parse;$/;"	m	class:Event
ev_pos	event.h	/^        list<Event *>::iterator ev_pos;$/;"	m	class:Event
ev_reactor	event.h	/^        Reactor * ev_reactor;$/;"	m	class:Event
ev_task	event.h	/^        Event * ev_task; $/;"	m	class:EventTask
event_count	reactor.h	/^        int event_count;$/;"	m	class:Reactor
event_count_ac	reactor.h	/^        int event_count_ac;$/;"	m	class:Reactor
event_mutex	reactor.h	/^    pthread_mutex_t event_mutex; $/;"	m	class:Reactor
event_queue_insert	reactor.cpp	/^void Reactor :: event_queue_insert(Event *ev,$/;"	f	class:Reactor
events	reactor.h	/^        struct epoll_event *events;$/;"	m	class:Reactor	typeref:struct:Reactor::epoll_event
evepoll	reactor.h	/^struct evepoll$/;"	s
evread	reactor.h	/^    Event * evread;$/;"	m	struct:evepoll
evwrite	reactor.h	/^    Event * evwrite;$/;"	m	struct:evepoll
excute	event.cpp	/^void Event :: excute()$/;"	f	class:Event
excute_fun	event.cpp	/^int Event :: excute_fun()$/;"	f	class:Event
excute_fun	event.cpp	/^int ReadEvent :: excute_fun()$/;"	f	class:ReadEvent
excute_fun	event.cpp	/^int WriteEvent :: excute_fun()$/;"	f	class:WriteEvent
expire_timer_ms	commonn/timer.cpp	/^Timer :: expire_timer_ms()$/;"	f	class:Timer
fds	reactor.h	/^        struct evepoll * fds;$/;"	m	class:Reactor	typeref:struct:Reactor::evepoll
find_line	net.cpp	/^find_line(char * req, int end, char label)$/;"	f
fp	commonn/asynLog.cpp	/^FILE * Log :: fp; $/;"	m	class:Log	file:
fp	commonn/asynLog.h	/^    static FILE * fp; $/;"	m	class:Log
free_list	commonn/memCache.cpp	/^Allocate :: obj * Allocate :: free_list[LISTS] = $/;"	m	class:Allocate	file:
free_list	commonn/memCache.h	/^    static obj * free_list[LISTS];$/;"	m	class:Allocate
free_list_link	commonn/memCache.h	/^        union obj * free_list_link;$/;"	m	union:Allocate::obj	typeref:union:Allocate::obj::obj
fresh_cache	Buffer.cpp	/^int Buffer :: fresh_cache(int len)$/;"	f	class:Buffer
front	commonn/queue.h	/^    int front;$/;"	m	struct:_queue_t
get	commonn/configParser.cpp	/^ConfigParser :: get(const std::string sectionName, const std::string keyName) const$/;"	f	class:ConfigParser
get	commonn/configParser.cpp	/^Section :: get(const std::string key) const$/;"	f	class:Section
get_buf_unhandle_cache	event.h	/^    inline void * get_buf_unhandle_cache()$/;"	f	class:ReadEvent
get_buf_unhandle_cache	event.h	/^    inline void * get_buf_unhandle_cache()$/;"	f	class:WriteEvent
get_buf_unhandle_num	event.h	/^    inline int get_buf_unhandle_num()$/;"	f	class:ReadEvent
get_buf_unhandle_num	event.h	/^    inline int get_buf_unhandle_num()$/;"	f	class:WriteEvent
get_buffer	event.h	/^    inline Buffer & get_buffer()$/;"	f	class:ReadEvent
get_buffer	event.h	/^    inline Buffer & get_buffer()$/;"	f	class:WriteEvent
get_cache	Buffer.h	/^        void * get_cache()$/;"	f	class:Buffer
get_epfd	reactor.h	/^    inline int get_epfd()$/;"	f	class:Reactor
get_ev_active	event.h	/^    inline int get_ev_active()$/;"	f	class:Event
get_ev_count	reactor.h	/^    inline int get_ev_count()$/;"	f	class:Reactor
get_ev_events	event.h	/^    inline int get_ev_events()$/;"	f	class:Event
get_ev_fd	event.h	/^    inline int get_ev_fd()$/;"	f	class:Event
get_ev_flags	event.h	/^    inline int get_ev_flags()$/;"	f	class:Event
get_ev_handle	event.h	/^    inline ev_handle get_ev_handle()$/;"	f	class:Event
get_ev_pos	event.h	/^    inline list<Event *>::iterator get_ev_pos()$/;"	f	class:Event
get_fds	reactor.h	/^    inline evepoll * get_fds()$/;"	f	class:Reactor
get_fds	reactor.h	/^    inline evepoll * get_fds(int idx)$/;"	f	class:Reactor
get_file	commonn/asynLog.h	/^    static FILE * get_file()$/;"	f	class:Log
get_parse_handle	event.h	/^    inline NonBlockFun * get_parse_handle()$/;"	f	class:Event
get_pdata	nf_server_core.h	/^        nf_server_pdata_t * get_pdata()$/;"	f	class:NfReactor
get_pthread_data	commonn/ThreadPool.cpp	/^get_pthread_data()$/;"	f
get_reactor	event.h	/^    inline Reactor * get_reactor()$/;"	f	class:Event
get_rmind_cache	Buffer.h	/^        int get_rmind_cache()$/;"	f	class:Buffer
get_server	nf_server_core.h	/^        nf_server_t * get_server()$/;"	f	class:NfReactor
get_server_data	nf_server.cpp	/^nf_server_t * NfServer :: get_server_data()$/;"	f	class:NfServer
get_sev	sapool.h	/^        nf_server_t  * get_sev()$/;"	f	class:SaListenEvent
get_tcp_sockaddr	net.cpp	/^get_tcp_sockaddr(char * addr, int * port, $/;"	f
get_time_msec	commonn/timer.cpp	/^Timer :: get_time_msec(const struct timeval * tv)$/;"	f	class:Timer
get_unhandle_cache	Buffer.h	/^        void * get_unhandle_cache()$/;"	f	class:Buffer
get_unhandle_data	Buffer.cpp	/^int Buffer :: get_unhandle_data(void * tmp)$/;"	f	class:Buffer
get_unhandle_num	Buffer.h	/^        int get_unhandle_num()$/;"	f	class:Buffer
idx	commonn/ThreadPool.h	/^        int idx;$/;"	m	class:CTask
init	Buffer.cpp	/^void Buffer :: init(int size)$/;"	f	class:Buffer
init	commonn/ThreadPool.cpp	/^int CThreadPool::init(int worker_size, int buff_size)$/;"	f	class:CThreadPool
init	commonn/asynLog.cpp	/^Log :: init(const char * name)$/;"	f	class:Log
init	commonn/memCache.cpp	/^Allocate :: init()$/;"	f	class:Allocate
init	event.h	/^    inline void init(int fd, $/;"	f	class:Event
init	nf_server.cpp	/^int NfServer :: init(const std::string & logPath)$/;"	f	class:NfServer
init	reactor.cpp	/^int Reactor :: init(int files, struct threadParas paras)$/;"	f	class:Reactor
init	sapool.h	/^    inline void init(nf_server_t * sev)$/;"	f	class:SaListenEvent
instance	commonn/singleton.h	/^        static T * instance()$/;"	f	class:Singleton
isEmpty	Buffer.h	/^        bool isEmpty()$/;"	f	class:Buffer
is_empty_q	commonn/queue.cpp	/^int is_empty_q(queue_t *q)$/;"	f
is_full_q	commonn/queue.cpp	/^int is_full_q(queue_t *q)$/;"	f
items	commonn/configParser.h	/^        std::map<std::string, std::string> items;$/;"	m	class:Section
lf_pool	lfpool.h	/^        static lfpool_t * lf_pool;        $/;"	m	class:LfServer
lfpool_t	lfpool.h	/^} lfpool_t;$/;"	t	typeref:struct:_lfpool_t
list_mutex	reactor.h	/^    pthread_mutex_t list_mutex;$/;"	m	class:Reactor
listen_port	nf_server_core.h	/^    size_t listen_port;$/;"	m	struct:_nf_server_t
listen_prio	nf_server_core.h	/^    size_t listen_prio; $/;"	m	struct:_nf_server_t
lock	commonn/singleton.h	/^        void lock()$/;"	f	class:MutexLock
lock	lfpool.h	/^    pthread_mutex_t lock;$/;"	m	struct:_lfpool_t
log_buffer	commonn/asynLog.cpp	/^queue<string> Log :: log_buffer;$/;"	m	class:Log	file:
log_buffer	commonn/asynLog.h	/^    static queue<string> log_buffer;   $/;"	m	class:Log
log_cond	commonn/asynLog.cpp	/^pthread_cond_t Log:: log_cond;$/;"	m	class:Log	file:
log_cond	commonn/asynLog.h	/^    static pthread_cond_t  log_cond;$/;"	m	class:Log
log_mutex	commonn/asynLog.cpp	/^pthread_mutex_t Log :: log_mutex;$/;"	m	class:Log	file:
log_mutex	commonn/asynLog.h	/^    static pthread_mutex_t log_mutex;$/;"	m	class:Log
mSections	commonn/configParser.h	/^    std::map<std::string, Section> mSections;$/;"	m	class:ConfigParser
m_cond	commonn/ThreadPool.h	/^	pthread_cond_t 		m_cond;$/;"	m	class:CThreadNotify
m_mutex	commonn/ThreadPool.h	/^	pthread_mutex_t 	m_mutex;$/;"	m	class:CThreadNotify
m_mutexattr	commonn/ThreadPool.h	/^	pthread_mutexattr_t	m_mutexattr;$/;"	m	class:CThreadNotify
m_task_cnt	commonn/ThreadPool.h	/^	    int		        m_task_cnt;$/;"	m	class:CWorkerThread
m_task_list	commonn/ThreadPool.h	/^	    list<CTask*>	m_task_list;$/;"	m	class:CWorkerThread
m_thread_id	commonn/ThreadPool.h	/^	    pthread_t		m_thread_id;$/;"	m	class:CWorkerThread
m_thread_idx	commonn/ThreadPool.h	/^	    int     		m_thread_idx;$/;"	m	class:CWorkerThread
m_thread_notify	commonn/ThreadPool.h	/^	    CThreadNotify	m_thread_notify;$/;"	m	class:CWorkerThread
m_work_buff	commonn/ThreadPool.h	/^        void *          m_work_buff;$/;"	m	class:CWorkerThread
m_work_len	commonn/ThreadPool.h	/^        int             m_work_len;$/;"	m	class:CWorkerThread
m_worker_list	commonn/ThreadPool.h	/^	    CWorkerThread* 	m_worker_list;$/;"	m	class:CThreadPool
m_worker_size	commonn/ThreadPool.h	/^	    int      		m_worker_size;$/;"	m	class:CThreadPool
main	rapool.h	/^    pthread_t main;$/;"	m	struct:_rapool_t
main	test/case/getline/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getline/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getn/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getn/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	testUnit/main.cpp	/^int main()$/;"	f
max	test/case/getline/client_simple.cpp	15;"	d	file:
max	test/case/getline/server_simple.cpp	14;"	d	file:
max	test/case/getn/client_simple.cpp	15;"	d	file:
max	test/case/getn/server_simple.cpp	14;"	d	file:
max	test/client_simple.cpp	15;"	d	file:
max	test/server_simple.cpp	14;"	d	file:
mem_mutex	commonn/memCache.cpp	/^pthread_mutex_t Allocate :: mem_mutex[LISTS];$/;"	m	class:Allocate	file:
mem_mutex	commonn/memCache.h	/^    static pthread_mutex_t mem_mutex[LISTS];$/;"	m	class:Allocate
move_forward	net.cpp	/^move_forward(char * req, int start, int end)$/;"	f
mutex	commonn/singleton.h	/^        pthread_mutex_t mutex;$/;"	m	class:MutexLock
name	nf_server_core.h	/^    char name[256];$/;"	m	struct:_nf_server_t
need_join	nf_server_core.h	/^    size_t need_join;$/;"	m	struct:_nf_server_t
net_accept	net.cpp	/^net_accept(int sockfd, struct sockaddr *sa, socklen_t * addrlen)$/;"	f
net_connect_to_ms	net.cpp	/^net_connect_to_ms(int sockfd, struct sockaddr *sa, $/;"	f
net_connect_to_tv	net.cpp	/^net_connect_to_tv(int fd, struct sockaddr * sa, $/;"	f
net_ep_add	net.cpp	/^net_ep_add(int epfd, $/;"	f
net_ep_add_in	net.cpp	/^net_ep_add_in(int epfd, int fd)$/;"	f
net_ep_add_in1	net.cpp	/^net_ep_add_in1(int epfd, int fd)$/;"	f
net_ep_create	net.cpp	/^net_ep_create(int size)$/;"	f
net_ep_del	net.cpp	/^net_ep_del(int epfd, int fd)$/;"	f
net_tcplisten	net.cpp	/^net_tcplisten(int port, int queue)$/;"	f
nevents	reactor.h	/^        int nevents;$/;"	m	class:Reactor
nevents	testUnit/main.cpp	/^const int nevents = 10;$/;"	v
next_check_time	rapool.h	/^    time_t next_check_time;$/;"	m	struct:_rapool_t
nf_init	nf_server_core.cpp	/^int NfReactor :: nf_init(int ssize, nf_server_t * svr)$/;"	f	class:NfReactor
nf_server_bind	nf_server_core.cpp	/^int nf_server_bind(nf_server_t * sev)$/;"	f
nf_server_create	nf_server.cpp	/^NfServer :: nf_server_create(const char * sev_name)$/;"	f	class:NfServer
nf_server_listen	nf_server_core.cpp	/^int nf_server_listen(nf_server_t * sev)$/;"	f
nf_server_pdata_t	nf_server_core.h	/^typedef struct _nf_server_pdata_t nf_server_pdata_t;$/;"	t	typeref:struct:_nf_server_pdata_t
nf_server_t	nf_server_core.h	/^typedef struct _nf_server_t nf_server_t;$/;"	t	typeref:struct:_nf_server_t
nfile	reactor.h	/^        int nfile;$/;"	m	class:Reactor
num	reactor.h	/^    int num;$/;"	m	struct:threadParas
obj	commonn/memCache.h	/^    union obj$/;"	u	class:Allocate
operator =	Buffer.cpp	/^Buffer & Buffer :: operator=(Buffer & bf)$/;"	f	class:Buffer
operator =	event.h	/^        Event & operator=(Event & ev)$/;"	f	class:Event
parseLine	nf_base_work.h	/^NonBlockReadLine * parseLine()$/;"	f
parse_handle	event.h	/^typedef int (*parse_handle)(int, void *);$/;"	t
parser_file	commonn/configParser.cpp	/^ConfigParser :: parser_file(const std::string &file)$/;"	f	class:ConfigParser
pdata	nf_server_core.h	/^        nf_server_pdata_t * pdata;$/;"	m	class:NfReactor
pkey	commonn/ThreadPool.cpp	/^static pthread_key_t pkey;$/;"	v	file:
ponce	commonn/ThreadPool.cpp	/^static pthread_once_t ponce = PTHREAD_ONCE_INIT; $/;"	v	file:
pool	reactor.h	/^        CThreadPool pool; $/;"	m	class:Reactor
poolPars	reactor.h	/^        struct threadParas poolPars;$/;"	m	class:Reactor	typeref:struct:Reactor::threadParas
pop_q	commonn/queue.cpp	/^int pop_q(queue_t *q, int *val)$/;"	f
produce_log	commonn/asynLog.cpp	/^Log :: produce_log(int event, const char * fmt, va_list args)$/;"	f	class:Log
pthread_key_del	commonn/ThreadPool.cpp	/^pthread_key_del(void)$/;"	f
push_q	commonn/queue.cpp	/^int push_q(queue_t *q, int val)$/;"	f
queue_t	commonn/queue.h	/^typedef struct _queue_t queue_t;$/;"	t	typeref:struct:_queue_t
ra_pool	rapool.h	/^       static rapool_t * ra_pool; $/;"	m	class:RaServer
rapool_add	rapool.cpp	/^RaServer :: rapool_add(nf_server_t * sev, int sock, struct sockaddr_in *addr)$/;"	f	class:RaServer
rapool_close_pool_sockets	rapool.cpp	/^RaServer :: rapool_close_pool_sockets(nf_server_t *sev, bool is_listenfd)$/;"	f	class:RaServer
rapool_del	rapool.cpp	/^RaServer :: rapool_del(nf_server_t *sev, int idx, int alive, bool remove)$/;"	f	class:RaServer
rapool_epoll_add_read	rapool.cpp	/^RaServer :: rapool_epoll_add_read(nf_server_t *sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_epoll_del	rapool.cpp	/^RaServer :: rapool_epoll_del(nf_server_t * sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_epoll_mod_read	rapool.cpp	/^RaServer :: rapool_epoll_mod_read(nf_server_t *sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_epoll_mod_write	rapool.cpp	/^RaServer :: rapool_epoll_mod_write(nf_server_t *sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_main	rapool.cpp	/^RaServer :: rapool_main(void *param)$/;"	f	class:RaServer
rapool_produce	rapool.cpp	/^RaServer :: rapool_produce(nf_server_t * sev, $/;"	f	class:RaServer
rapool_reactor	rapool.cpp	/^RaServer :: rapool_reactor(rapool_t * pool, nf_server_pdata_t * pdata)$/;"	f	class:RaServer
rapool_sock_item_t	rapool.h	/^typedef struct _rapool_sock_item_t rapool_sock_item_t;$/;"	t	typeref:struct:_rapool_sock_item_t
rapool_t	rapool.h	/^typedef struct _rapool_t rapool_t;$/;"	t	typeref:struct:_rapool_t
rapool_t	rapool.h	/^}rapool_t;$/;"	t	typeref:struct:_rapool_t
rapool_workers	rapool.cpp	/^RaServer :: rapool_workers(void * param)$/;"	f	class:RaServer
rd_init	event.h	/^    inline void rd_init(int fd,$/;"	f	class:ReadEvent
reactor	nf_server_core.h	/^    NfReactor * reactor;$/;"	m	struct:_nf_server_pdata_t
reactor_num	nf_server_core.h	/^    size_t reactor_num;   \/\/reactor num$/;"	m	struct:_nf_server_t
read_handle	nf_server_core.h	/^    ev_handle read_handle;$/;"	m	struct:_nf_server_t
read_parse_handle	nf_server_core.h	/^    parse_handle read_parse_handle;$/;"	m	struct:_nf_server_t
read_to	nf_server_core.h	/^    size_t read_to;$/;"	m	struct:_nf_server_t
readn	net.cpp	/^readn(int fd, void *usrbuf, size_t n)$/;"	f
readn_to_ms	net.cpp	/^readn_to_ms(int fd, void *ptr, size_t nbytes, int msecs)$/;"	f
rear	commonn/queue.h	/^    int rear;$/;"	m	struct:_queue_t
refill	commonn/memCache.cpp	/^Allocate :: refill(size_t n)$/;"	f	class:Allocate
rio_bufptr	net.h	/^    char * rio_bufptr;\/\/ ½¨ÒéÖ±½Ó¶Áµ½Ïß³Ì¹¤×÷¿¿Õ¼ä $/;"	m	struct:_rio_t
rio_cnt	net.h	/^    int rio_cnt;      \/\/ ÄÚÖÃ·â×°readÊ±Ê¹ÓÃ$/;"	m	struct:_rio_t
rio_fd	net.h	/^    int rio_fd;$/;"	m	struct:_rio_t
rio_init	net.cpp	/^void rio_init(rio_t *rp, int fd, int len)$/;"	f
rio_len	net.h	/^    size_t rio_len;   \/\/ ²»½¨ÒéÊ¹ÓÃ·â×°read²Ù×÷$/;"	m	struct:_rio_t
rio_ptr	net.h	/^    char * rio_ptr;   $/;"	m	struct:_rio_t
rio_read	net.cpp	/^rio_read(rio_t *rp, char *usrbuf, size_t n)$/;"	f	file:
rio_readline	net.cpp	/^rio_readline(rio_t *rp, void *usrbuf, size_t maxlen, int * st)$/;"	f
rio_readn	net.cpp	/^rio_readn(rio_t *rp, void *usrbuf, size_t n, int * st)$/;"	f
rio_t	net.h	/^} rio_t;$/;"	t	typeref:struct:_rio_t
rp	rapool.h	/^    rio_t rp;$/;"	m	struct:_rapool_sock_item_t
run	event.cpp	/^void EventTask :: run()$/;"	f	class:EventTask
run	nf_server.cpp	/^int NfServer :: run()$/;"	f	class:NfServer
run	nf_server_core.h	/^    int run;     $/;"	m	struct:_nf_server_t
run	rapool.h	/^    int * run;$/;"	m	struct:_rapool_t
run	reactor.h	/^        bool run;$/;"	m	class:Reactor
scan	commonn/configParser.cpp	/^ConfigParser :: scan() const$/;"	f	class:ConfigParser
scan	commonn/configParser.cpp	/^Section :: scan() const$/;"	f	class:Section
sendn	net.cpp	/^sendn(int fd, void *usrbuf, size_t n)$/;"	f
sendn_to_ms	net.cpp	/^sendn_to_ms(int fd, const void *ptr, size_t nbytes, int msecs)$/;"	f
server_type	nf_server_core.h	/^    size_t server_type;$/;"	m	struct:_nf_server_t
set	commonn/configParser.h	/^        inline void set(const std::string &key, const std::string &val)$/;"	f	class:Section
set	commonn/configParser.h	/^    inline void set(const std::string &sectionName, const std::string &keyName, $/;"	f	class:ConfigParser
setTaskIdx	commonn/ThreadPool.h	/^        void setTaskIdx(int num)$/;"	f	class:CTask
set_clc_fd	net.cpp	/^set_clc_fd(int fd, int flags)$/;"	f
set_ev_flags	event.h	/^    inline void set_ev_flags(int flg)$/;"	f	class:Event
set_event_active	reactor.cpp	/^bool Reactor :: set_event_active(Event * ev)$/;"	f	class:Reactor
set_event_unactive	reactor.cpp	/^bool Reactor :: set_event_unactive(Event * ev)$/;"	f	class:Reactor
set_fd	net.cpp	/^set_fd(int fd, int flags)$/;"	f
set_fd_block	net.cpp	/^set_fd_block(int fd)$/;"	f
set_fd_noblock	net.cpp	/^set_fd_noblock(int fd)$/;"	f
set_file	commonn/asynLog.h	/^    static void set_file(FILE * file)$/;"	f	class:Log
set_level	commonn/asynLog.h	/^    static void set_level(int level)$/;"	f	class:Log
set_linger	net.cpp	/^set_linger(int fd, int val)$/;"	f
set_parse_read_handle	nf_server.cpp	/^int NfServer :: set_parse_read_handle(parse_handle read_handle)$/;"	f	class:NfServer
set_parse_write_handle	nf_server.cpp	/^int NfServer :: set_parse_write_handle(parse_handle write_handle)$/;"	f	class:NfServer
set_pthread_data	commonn/ThreadPool.cpp	/^set_pthread_data(CWorkerThread * data)$/;"	f
set_read_handle	nf_server.cpp	/^int NfServer :: set_read_handle(ev_handle read_handle)$/;"	f	class:NfServer
set_server_name	nf_server.cpp	/^int NfServer :: set_server_name(const char * sev_name)$/;"	f	class:NfServer
set_sev_socketopt	nf_server_core.cpp	/^int set_sev_socketopt(nf_server_t *sev, int fd)$/;"	f
set_status	commonn/asynLog.h	/^    static void set_status(int status)$/;"	f	class:Log
set_tcp_sockaddr	net.cpp	/^set_tcp_sockaddr(char * addr, int port, $/;"	f
set_write_handle	nf_server.cpp	/^int NfServer :: set_write_handle(ev_handle write_handle)$/;"	f	class:NfServer
sev	sapool.h	/^        nf_server_t * sev;$/;"	m	class:SaListenEvent
sev_data	nf_server.h	/^        nf_server_t *sev_data; \/\/server ºËÐÄÊý¾Ý½á¹¹$/;"	m	class:NfServer
sev_sock_id	rapool.h	/^    int sev_sock_id;$/;"	m	struct:_rapool_t
sev_socket	nf_server_core.h	/^    int sev_socket; $/;"	m	struct:_nf_server_t
size	commonn/queue.h	/^    int size;$/;"	m	struct:_queue_t
size	rapool.h	/^    int size;$/;"	m	struct:_rapool_t
sock	rapool.h	/^    int sock;$/;"	m	struct:_rapool_sock_item_t
sock_family	nf_server_core.h	/^    int sock_family;$/;"	m	struct:_nf_server_t
sock_timeout	rapool.h	/^    long long sock_timeout;    $/;"	m	struct:_rapool_sock_item_t
sockets	rapool.h	/^    rapool_sock_item_t * sockets;$/;"	m	struct:_rapool_t
socksize	nf_server_core.h	/^    size_t socksize;$/;"	m	struct:_nf_server_t
stack_size	nf_server_core.h	/^    size_t stack_size; \/\/Ïß³ÌÕ»´óÐ¡$/;"	m	struct:_nf_server_t
start	reactor.cpp	/^int Reactor :: start(int status)$/;"	f	class:Reactor
status	nf_server_core.h	/^    SERVER_STATUS_T status;$/;"	m	struct:_nf_server_t
status	rapool.h	/^    int status;$/;"	m	struct:_rapool_sock_item_t
status	reactor.h	/^    int status;$/;"	m	struct:evepoll
stop	commonn/asynLog.h	/^    static void stop()$/;"	f	class:Log
str_idx	Buffer.h	/^        int str_idx;$/;"	m	class:Buffer
str_prefix	commonn/asynLog.cpp	/^string Log :: str_prefix[4] = {"[DEBUG]  ", $/;"	m	class:Log	file:
str_prefix	commonn/asynLog.h	/^    static string str_prefix[4];$/;"	m	class:Log
svr	factory.h	/^static struct NfServer * svr[] = $/;"	v	typeref:struct:NfServer
svr	nf_server_core.h	/^        nf_server_t * svr;$/;"	m	class:NfReactor
svr_destroy	rapool.cpp	/^RaServer :: svr_destroy()$/;"	f	class:RaServer
svr_init	sapool.cpp	/^SaServer :: svr_init()$/;"	f	class:SaServer
svr_join	rapool.cpp	/^RaServer :: svr_join()$/;"	f	class:RaServer
svr_listen	rapool.cpp	/^RaServer :: svr_listen()$/;"	f	class:RaServer
svr_pause	rapool.cpp	/^RaServer :: svr_pause()$/;"	f	class:RaServer
svr_reactor	nf_server_core.h	/^    NfReactor * svr_reactor;$/;"	m	struct:_nf_server_t
svr_resume	rapool.cpp	/^RaServer :: svr_resume()$/;"	f	class:RaServer
svr_run	rapool.cpp	/^RaServer :: svr_run()$/;"	f	class:RaServer
svr_run	sapool.cpp	/^SaServer :: svr_run()$/;"	f	class:SaServer
svr_set_stragy	rapool.cpp	/^RaServer :: svr_set_stragy(BaseWork * sta)$/;"	f	class:RaServer
svr_type	factory.h	/^        int svr_type;$/;"	m	class:Factory
test_read_fun	testUnit/main.cpp	/^void test_read_fun(int fd, short events, void * arg)$/;"	f
test_write_fun	testUnit/main.cpp	/^void test_write_fun(int fd, short events, void * arg)$/;"	f
threadParas	reactor.h	/^struct threadParas$/;"	s
thread_num	nf_server_core.h	/^    size_t thread_num;    \/\/Ã¿¸öreactorµÄthread num$/;"	m	struct:_nf_server_t
thread_usr_buf	nf_server_core.h	/^    size_t thread_usr_buf;$/;"	m	struct:_nf_server_t
timeout	rapool.h	/^    int timeout;        \/\/epollµÄ³¬Ê±Ê±¼ä$/;"	m	struct:_rapool_t
timer	commonn/timer.h	/^        multimap<long long, pair<timer_callback_proc, void *> > timer;$/;"	m	class:Timer
timer_callback_proc	commonn/timer.h	/^        typedef int (* timer_callback_proc)(void * param);$/;"	t	class:Timer
top_timer_ms	commonn/timer.cpp	/^Timer :: top_timer_ms()$/;"	f	class:Timer
tstLabel	nf_base_work.cpp	/^static const char tstLabel = '!';$/;"	v	file:
unlock	commonn/singleton.h	/^        void unlock()$/;"	f	class:MutexLock
using_size	rapool.h	/^    long long using_size;$/;"	m	struct:_rapool_t
w_allo_cache	net.h	/^    char * w_allo_cache;$/;"	m	struct:_rio_t
w_allo_len	net.h	/^    int w_allo_len;    $/;"	m	struct:_rio_t
w_cache	net.h	/^    char * w_cache;$/;"	m	struct:_rio_t
w_cache_len	net.h	/^    int w_cache_len;$/;"	m	struct:_rio_t
work	nf_base_work.cpp	/^int NonBlockReadLine :: work(int fd, $/;"	f	class:NonBlockReadLine
work	nf_base_work.cpp	/^int NonBlockWrite :: work(int fd, void * arg)$/;"	f	class:NonBlockWrite
work	test/case/getline/client_simple.cpp	/^void * work(void * arg)$/;"	f
work	test/case/getn/client_simple.cpp	/^void * work(void * arg)$/;"	f
work	test/client_simple.cpp	/^void * work(void * arg)$/;"	f
work_prio	nf_server_core.h	/^    size_t work_prio;$/;"	m	struct:_nf_server_t
writeData	nf_base_work.h	/^NonBlockWrite * writeData()$/;"	f
write_handle	nf_server_core.h	/^    ev_handle write_handle;$/;"	m	struct:_nf_server_t
write_log	commonn/asynLog.cpp	/^Log :: write_log(void *)$/;"	f	class:Log
write_parse_handle	nf_server_core.h	/^    parse_handle write_parse_handle;$/;"	m	struct:_nf_server_t
write_to	nf_server_core.h	/^    size_t write_to;$/;"	m	struct:_nf_server_t
wt_init	event.h	/^    inline void wt_init(int fd,$/;"	f	class:WriteEvent
~Buffer	Buffer.h	/^        virtual ~Buffer()$/;"	f	class:Buffer
~CTask	commonn/ThreadPool.h	/^        virtual ~CTask(){}$/;"	f	class:CTask
~CThreadNotify	commonn/ThreadPool.cpp	/^CThreadNotify :: ~CThreadNotify()$/;"	f	class:CThreadNotify
~CThreadPool	commonn/ThreadPool.cpp	/^CThreadPool::~CThreadPool()$/;"	f	class:CThreadPool
~CWorkerThread	commonn/ThreadPool.cpp	/^CWorkerThread::~CWorkerThread()$/;"	f	class:CWorkerThread
~ConfigParser	commonn/configParser.h	/^        virtual ~ConfigParser(){}$/;"	f	class:ConfigParser
~Event	event.h	/^    virtual ~Event(){};$/;"	f	class:Event
~Factory	factory.h	/^        virtual ~Factory(){};$/;"	f	class:Factory
~LfServer	lfpool.h	/^        virtual ~LfServer(){};$/;"	f	class:LfServer
~MutexLock	commonn/singleton.h	/^        ~MutexLock()$/;"	f	class:MutexLock
~NfServer	nf_server.cpp	/^NfServer :: ~NfServer()$/;"	f	class:NfServer
~NonBlockFun	nf_base_work.h	/^    virtual ~NonBlockFun(){}$/;"	f	class:NonBlockFun
~NonBlockReadLine	nf_base_work.h	/^    virtual ~NonBlockReadLine(){}$/;"	f	class:NonBlockReadLine
~NonBlockReadLine	nf_base_work.h	/^    virtual ~NonBlockReadLine(){}$/;"	f	class:NonBlockWrite
~RaServer	rapool.h	/^        virtual ~RaServer(){};$/;"	f	class:RaServer
~SaServer	sapool.h	/^        virtual ~SaServer(){};$/;"	f	class:SaServer
~Server	commonn/Server.h	/^        virtual ~Server(){};$/;"	f	class:Server
