!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AFLAGS	Makefile	/^AFLAGS := -cvr$/;"	m
ALIGN	commonn/memCache.h	/^enum {ALIGN = 64};$/;"	e	enum:__anon1
AR	Makefile	/^AR := ar$/;"	m
Allocate	commonn/memCache.h	/^class Allocate$/;"	c
BUFLEN	test/case/getline/server_simple.cpp	15;"	d	file:
BUFLEN	test/case/getn/server_simple.cpp	15;"	d	file:
BUFLEN	test/server_simple.cpp	15;"	d	file:
BUSY	rapool.cpp	/^    BUSY$/;"	e	enum:__anon11	file:
BUSY	sapool.cpp	/^    BUSY$/;"	e	enum:__anon14	file:
BaseWork	nf_server_core.h	/^class BaseWork$/;"	c
CFLAGS	Makefile	/^CFLAGS := -g -c -Wall$/;"	m
CHUNK_NODE	commonn/memCache.h	/^enum {CHUNK_NODE = 20};$/;"	e	enum:__anon4
COMMON_DIR	Makefile	/^COMMON_DIR := .\/commonn$/;"	m
COM_OBJS	Makefile	/^COM_OBJS := timer.o queue.o memCache.o asynLog.o$/;"	m
CXX	Makefile	/^CXX := g++$/;"	m
ConfigParser	commonn/configParser.h	/^        ConfigParser(){}$/;"	f	class:ConfigParser
ConfigParser	commonn/configParser.h	/^class ConfigParser$/;"	c
DEBUG	commonn/asynLog.cpp	/^Log :: DEBUG(const char * fmt, ...)$/;"	f	class:Log
DEFAULT_CHECK_INTERVAL	sapool.cpp	/^    DEFAULT_CHECK_INTERVAL = 10,  \/\/\/Ä¬ÈÏcheck_interval, 10ms$/;"	e	enum:__anon13	file:
DEFAULT_QUEUE_LEN	sapool.cpp	/^    DEFAULT_QUEUE_LEN = 100,      \/\/\/Ä¬ÈÏµÄµÈ´ý¶ÓÁÐµÄ³¤¶È 100$/;"	e	enum:__anon13	file:
DEFAULT_SOCK_NUM	sapool.cpp	/^    DEFAULT_SOCK_NUM = 500,       \/\/\/Í¬Ê±Î¬»¤µÄ×î´ósock¾ä±úÊý£¬500$/;"	e	enum:__anon13	file:
DEFAULT_TIMEOUT	sapool.cpp	/^    DEFAULT_TIMEOUT = 60000,         \/\/\/µÈ´ý¶ÓÁÐÀïÃæµÄÄ¬ÈÏ³¬Ê±Ê±¼ät, 60s$/;"	e	enum:__anon13	file:
ERROR	commonn/asynLog.cpp	/^Log :: ERROR(const char * fmt, ...)$/;"	f	class:Log
EV_ACTIVE	util.h	12;"	d
EV_INIT	util.h	10;"	d
EV_INSERTED	util.h	11;"	d
EV_ONCE	util.h	18;"	d
EV_PERSIST	util.h	8;"	d
EV_READ	util.h	6;"	d
EV_READUNFIN	util.h	13;"	d
EV_THREAD	util.h	17;"	d
EV_TIMEOUT	util.h	5;"	d
EV_WRITE	util.h	7;"	d
EV_WRITEUNFIN	util.h	14;"	d
EXECUTE	Makefile	/^EXECUTE := $(TAR_OBJ)$/;"	m
Event	event.h	/^    explicit Event() : ev_fd(0),$/;"	f	class:Event
Event	event.h	/^class Event$/;"	c
FD_ACTIVE	util.h	22;"	d
FD_NOSLEEP	util.h	21;"	d
FREELIST_INDEX	commonn/memCache.h	/^    static size_t FREELIST_INDEX(size_t n)$/;"	f	class:Allocate
Factory	factory.h	/^        Factory(const std::string  & conf)$/;"	f	class:Factory
Factory	factory.h	/^class Factory$/;"	c
IDLE	nf_server_app.cpp	/^    IDLE = 0$/;"	e	enum:__anon12	file:
IDLE	rapool.cpp	/^    IDLE = 0,$/;"	e	enum:__anon11	file:
IDLE	sapool.cpp	/^    IDLE = 0,$/;"	e	enum:__anon14	file:
INIT	nf_server_core.h	/^    INIT    = 0,$/;"	e	enum:__anon7
IO_readcb	net_svr_cb.cpp	/^void IO_readcb(int fd,$/;"	f
LEVEL	commonn/asynLog.cpp	/^int Log :: LEVEL = LOG_DEBUG;$/;"	m	class:Log	file:
LEVEL	commonn/asynLog.h	/^    static int LEVEL;$/;"	m	class:Log
LISTENER_PRIORITY	rapool.h	20;"	d
LISTENER_PRIORITY	sapool.h	26;"	d
LISTS	commonn/memCache.h	/^enum {LISTS = MAX_BYTES\/ALIGN};$/;"	e	enum:__anon3
LOG_DEBUG	commonn/asynLog.h	/^    LOG_DEBUG,$/;"	e	enum:__anon5
LOG_ERROR	commonn/asynLog.h	/^    LOG_ERROR,$/;"	e	enum:__anon5
LOG_INIT	commonn/asynLog.h	/^    LOG_INIT,$/;"	e	enum:__anon6
LOG_MAXLINE	commonn/asynLog.h	/^    LOG_MAXLINE = 6000$/;"	e	enum:__anon5
LOG_NOTICE	commonn/asynLog.h	/^    LOG_NOTICE,$/;"	e	enum:__anon5
LOG_RUN	commonn/asynLog.h	/^    LOG_RUN,$/;"	e	enum:__anon6
LOG_STOP	commonn/asynLog.h	/^    LOG_STOP$/;"	e	enum:__anon6
LOG_WARN	commonn/asynLog.h	/^    LOG_WARN, $/;"	e	enum:__anon5
LfBaseWork	nf_server_app.h	/^class LfBaseWork : public BaseWork$/;"	c
LfReadLine	nf_server_app.h	/^class LfReadLine : public LfBaseWork$/;"	c
LfServer	lfpool.h	/^        LfServer(){};$/;"	f	class:LfServer
LfServer	lfpool.h	/^class LfServer : public NfServer$/;"	c
Lock	commonn/singleton.h	/^        static MutexLock Lock;$/;"	m	class:Singleton
Lock	commonn/singleton.h	/^MutexLock Singleton<T>::Lock;$/;"	m	class:Singleton
Log	commonn/asynLog.h	/^class Log$/;"	c
MAX	rapool.cpp	16;"	d	file:
MAX	sapool.cpp	18;"	d	file:
MAX_BYTES	commonn/memCache.h	/^enum {MAX_BYTES = 1024};$/;"	e	enum:__anon2
MutexLock	commonn/singleton.h	/^        MutexLock()$/;"	f	class:MutexLock
MutexLock	commonn/singleton.h	/^class MutexLock$/;"	c
NFSVR_LFPOOL	nf_server_core.h	/^    NFSVR_LFPOOL = 0,    \/\/½¨ÒéÓÃÓÚ¶àÏß³Ì¶ÌÁ¬½Ó                                                                   $/;"	e	enum:__anon8
NFSVR_LONG_CONNEC	nf_server_core.h	/^    NFSVR_LONG_CONNEC$/;"	e	enum:__anon9
NFSVR_POOL_NUM	nf_server_core.h	/^    NFSVR_POOL_NUM,     \/\/µ±Ç°ÓÐ¶àÉÙ¸öpool    $/;"	e	enum:__anon8
NFSVR_RAPOOL	nf_server_core.h	/^    NFSVR_RAPOOL,        \/\/reactor + pthread IOÃÜ¼¯£¬thread ÊýÓëºËÓÐ¹Ø$/;"	e	enum:__anon8
NFSVR_SAPOOL	nf_server_core.h	/^    NFSVR_SAPOOL,        \/\/½¨ÒéÓÃÓÚ¶àÏß³Ì³¤Á¬½Ó     $/;"	e	enum:__anon8
NFSVR_SHORT_CONNEC	nf_server_core.h	/^    NFSVR_SHORT_CONNEC = 0,$/;"	e	enum:__anon9
NOTICE	commonn/asynLog.cpp	/^Log :: NOTICE(const char * fmt, ...)$/;"	f	class:Log
NfServer	nf_server.cpp	/^NfServer :: NfServer()$/;"	f	class:NfServer
NfServer	nf_server.h	/^class NfServer : public Server$/;"	c
OBJS	Makefile	/^OBJS := net.o nf_server.o rapool.o timer.o nf_server_core.o \\$/;"	m
PAUSE	nf_server_core.h	/^    PAUSE   = 2,$/;"	e	enum:__anon7
RA_CHECK_INTERVAL	rapool.cpp	/^    RA_CHECK_INTERVAL = 10,  \/\/\/Ä¬ÈÏcheck_interval, 10ms$/;"	e	enum:__anon10	file:
RA_SOCK_NUM	rapool.cpp	/^    RA_SOCK_NUM = 500,       \/\/\/Í¬Ê±Î¬»¤µÄ×î´ósock¾ä±úÊý£¬500$/;"	e	enum:__anon10	file:
RA_TIMEOUT	rapool.cpp	/^    RA_TIMEOUT = 60,         \/\/\/µÈ´ý¶ÓÁÐÀïÃæµÄÄ¬ÈÏ³¬Ê±Ê±¼ät, 60s$/;"	e	enum:__anon10	file:
READY	sapool.cpp	/^    READY,$/;"	e	enum:__anon14	file:
ROUND_UP	commonn/memCache.h	/^    static size_t ROUND_UP(size_t n)$/;"	f	class:Allocate
RUNNING	nf_server_core.h	/^    RUNNING = 1,$/;"	e	enum:__anon7
RaBaseWork	nf_server_app.h	/^class RaBaseWork : public BaseWork$/;"	c
RaReadLine	nf_server_app.h	/^class RaReadLine : public RaBaseWork$/;"	c
RaServer	rapool.h	/^        RaServer(){};$/;"	f	class:RaServer
RaServer	rapool.h	/^class RaServer : public NfServer$/;"	c
Reactor	reactor.h	/^        Reactor() : event_count(0),$/;"	f	class:Reactor
Reactor	reactor.h	/^class Reactor$/;"	c
ReadEvent	event.h	/^        explicit ReadEvent() : cache(NULL),$/;"	f	class:ReadEvent
ReadEvent	event.h	/^        explicit ReadEvent(void * ca, int len) : cache(ca),$/;"	f	class:ReadEvent
ReadEvent	event.h	/^class ReadEvent : public Event$/;"	c
SERVER_STATUS_T	nf_server_core.h	/^}SERVER_STATUS_T;$/;"	t	typeref:enum:__anon7
STATUS	commonn/asynLog.cpp	/^int Log :: STATUS = LOG_INIT;$/;"	m	class:Log	file:
STATUS	commonn/asynLog.h	/^    static int STATUS;   $/;"	m	class:Log
STOP	nf_server_core.h	/^    STOP    = 3$/;"	e	enum:__anon7
SVR_OBJS	Makefile	/^SVR_OBJS := net.o nf_server.o rapool.o nf_server_core.o \\$/;"	m
SaBaseWork	nf_server_app.h	/^class SaBaseWork : public BaseWork$/;"	c
SaReadLine	nf_server_app.h	/^class SaReadLine : public SaBaseWork$/;"	c
SaServer	sapool.h	/^        SaServer(){};$/;"	f	class:SaServer
SaServer	sapool.h	/^class SaServer : public NfServer$/;"	c
Section	commonn/configParser.h	/^class Section$/;"	c
Server	commonn/Server.h	/^        Server(){};$/;"	f	class:Server
Server	commonn/Server.h	/^class Server$/;"	c
Singleton	commonn/singleton.h	/^class Singleton$/;"	c
TAR_DIR	Makefile	/^TAR_DIR := .\/$/;"	m
TAR_OBJ	Makefile	/^TAR_OBJ := lib_nf_svr.a$/;"	m
THREAD	Makefile	/^THREAD := -lpthread$/;"	m
Timer	commonn/timer.h	/^class Timer$/;"	c
WARN	commonn/asynLog.cpp	/^Log :: WARN(const char * fmt, ...)$/;"	f	class:Log
WORKER_PRIORITY	rapool.h	21;"	d
WORKER_PRIORITY	sapool.h	27;"	d
WriteEvent	event.h	/^        explicit WriteEvent() : cache(NULL),$/;"	f	class:WriteEvent
WriteEvent	event.h	/^        explicit WriteEvent(void * ca, int len) : cache(ca),$/;"	f	class:WriteEvent
WriteEvent	event.h	/^class WriteEvent : public Event$/;"	c
_ASYN_LOG_	commonn/asynLog.h	13;"	d
_CONFIG_PARSER_H	commonn/configParser.h	14;"	d
_EVENT_	event.h	2;"	d
_Lf_SERVER_H	lfpool.h	2;"	d
_MEM_CACHE_	commonn/memCache.h	13;"	d
_NFSERVER_APP_H	nf_server_app.h	2;"	d
_NFSERVER_CORE_H	nf_server_core.h	15;"	d
_NF_SERVER_H	nf_server.h	12;"	d
_QUEUE_H	commonn/queue.h	12;"	d
_REACTOR_	reactor.h	2;"	d
_SERVER_H	commonn/Server.h	9;"	d
_TIMER_	commonn/timer.h	14;"	d
_UTIL_	util.h	2;"	d
__NET_H__	net.h	12;"	d
__RAPOOL_H_	rapool.h	14;"	d
__SAPOOL_H_	sapool.h	19;"	d
_initialized	commonn/singleton.h	/^        static bool _initialized;$/;"	m	class:Singleton
_initialized	commonn/singleton.h	/^bool Singleton<T>::_initialized = false;$/;"	m	class:Singleton
_instance	commonn/singleton.h	/^        static T * _instance;$/;"	m	class:Singleton
_instance	commonn/singleton.h	/^T * Singleton<T>::_instance = NULL;$/;"	m	class:Singleton
_lfpool_t	lfpool.h	/^typedef struct _lfpool_t $/;"	s
_nf_server_pdata_t	nf_server_core.h	/^struct _nf_server_pdata_t$/;"	s
_nf_server_t	nf_server_core.h	/^struct _nf_server_t$/;"	s
_queue_t	commonn/queue.h	/^struct _queue_t$/;"	s
_rapool_sock_item_t	rapool.h	/^struct _rapool_sock_item_t$/;"	s
_rapool_t	rapool.h	/^typedef struct _rapool_t$/;"	s
_rio_t	net.h	/^typedef struct _rio_t$/;"	s
_sapool_sock_item_t	sapool.h	/^struct _sapool_sock_item_t$/;"	s
_sapool_t	sapool.h	/^struct _sapool_t$/;"	s
_singleton_h	commonn/singleton.h	13;"	d
add_event	reactor.cpp	/^int Reactor :: add_event(Event * ev,$/;"	f	class:Reactor
add_listen_socket	rapool.cpp	/^RaServer :: add_listen_socket(nf_server_t *sev, int listenfd)$/;"	f	class:RaServer
add_listen_socket	sapool.cpp	/^SaServer :: add_listen_socket(nf_server_t *sev, int listenfd)$/;"	f	class:SaServer
add_prefix	commonn/asynLog.cpp	/^add_prefix(char * dest, const string &add)$/;"	f
add_timer_ms	commonn/timer.cpp	/^Timer :: add_timer_ms(long long time, $/;"	f	class:Timer
addr	rapool.h	/^    struct sockaddr_in addr;$/;"	m	struct:_rapool_sock_item_t	typeref:struct:_rapool_sock_item_t::sockaddr_in
addr	sapool.h	/^    struct sockaddr_in addr;$/;"	m	struct:_sapool_sock_item_t	typeref:struct:_sapool_sock_item_t::sockaddr_in
allocate	commonn/memCache.cpp	/^Allocate :: allocate(size_t n)$/;"	f	class:Allocate
array	commonn/queue.h	/^    int *array;$/;"	m	struct:_queue_t
backlog	nf_server_core.h	/^    size_t backlog;$/;"	m	struct:_nf_server_t
buffer	commonn/asynLog.cpp	/^char Log :: buffer[LOG_MAXLINE];$/;"	m	class:Log	file:
buffer	commonn/asynLog.h	/^    static char buffer[LOG_MAXLINE];$/;"	m	class:Log
c_len	event.h	/^        int c_len;$/;"	m	class:ReadEvent
c_len	event.h	/^        int c_len;$/;"	m	class:WriteEvent
cache	event.h	/^        void * cache;$/;"	m	class:ReadEvent
cache	event.h	/^        void * cache;$/;"	m	class:WriteEvent
cache	net.h	/^    char * cache;$/;"	m	struct:_rio_t
cache_len	net.h	/^    int cache_len;$/;"	m	struct:_rio_t
call_back_timeout	rapool.cpp	/^RaServer :: call_back_timeout(void * param)$/;"	f	class:RaServer
cap	commonn/queue.h	/^    int cap;$/;"	m	struct:_queue_t
cb_work	nf_server_core.h	/^    nf_callback_proc cb_work;$/;"	m	struct:_nf_server_t
check_interval	nf_server_core.h	/^    size_t check_interval;  \/\/sapool$/;"	m	struct:_nf_server_t
check_interval	rapool.h	/^    int check_interval;    \/\/Î¢Ãî¼¶±ðÖ§³Ö³¬Ê±$/;"	m	struct:_rapool_t
check_interval	sapool.h	/^    int check_interval;    \/\/Î¢Ãî¼¶±ðÖ§³Ö³¬Ê±$/;"	m	struct:_sapool_t
check_socket_queue	sapool.cpp	/^SaServer :: check_socket_queue(nf_server_t *sev)$/;"	f	class:SaServer
client_addr	nf_server_core.h	/^    struct sockaddr_in client_addr;$/;"	m	struct:_nf_server_pdata_t	typeref:struct:_nf_server_pdata_t::sockaddr_in
client_data	commonn/memCache.h	/^        char client_data[1];$/;"	m	union:Allocate::obj
connect_to	nf_server_core.h	/^    size_t connect_to;$/;"	m	struct:_nf_server_t
connect_type	nf_server_core.h	/^    size_t connect_type; $/;"	m	struct:_nf_server_t
createData	test/case/getline/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
createData	test/case/getn/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
createData	test/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
create_key_once	nf_server_core.cpp	/^create_key_once(void)$/;"	f	file:
create_q	commonn/queue.cpp	/^int create_q(queue_t *q, int qcap)$/;"	f
create_svr	factory.h	/^    NfServer * create_svr()$/;"	f	class:Factory
ctime	commonn/asynLog.cpp	/^ctime(char * t_time, size_t n)$/;"	f
deallocate	commonn/memCache.cpp	/^Allocate :: deallocate(void * p, size_t n)$/;"	f	class:Allocate
default_hand	net.cpp	/^default_hand(int sig)$/;"	f
default_handle	test/server_simple.cpp	/^default_handle()$/;"	f
del_timer_ms	commonn/timer.cpp	/^Timer :: del_timer_ms(long long time, const void * const param)$/;"	f	class:Timer
destroy	commonn/singleton.h	/^        static void destroy()$/;"	f	class:Singleton
destroy	nf_server.cpp	/^int NfServer :: destroy()$/;"	f	class:NfServer
destroy_q	commonn/queue.cpp	/^int destroy_q(queue_t *q)$/;"	f
empty_q	commonn/queue.cpp	/^int empty_q(queue_t *q)$/;"	f
empty_str	commonn/configParser.cpp	/^static const std::string empty_str = "";$/;"	v	file:
ep_events	rapool.h	/^    struct epoll_event * ep_events;$/;"	m	struct:_rapool_t	typeref:struct:_rapool_t::epoll_event
ep_events	sapool.h	/^    struct epoll_event * ep_events;$/;"	m	struct:_sapool_t	typeref:struct:_sapool_t::epoll_event
ep_size	nf_server_core.h	/^    size_t ep_size;$/;"	m	struct:_nf_server_pdata_t
epfd	nf_server_core.h	/^    int epfd;$/;"	m	struct:_nf_server_pdata_t
epfd	nf_server_core.h	/^    int epfd;$/;"	m	struct:_nf_server_t
epfd	rapool.h	/^    int epfd;$/;"	m	struct:_rapool_t
epfd	reactor.h	/^        int epfd;$/;"	m	class:Reactor
epfd	sapool.h	/^    int epfd;$/;"	m	struct:_sapool_t
epoll_add_event	reactor.cpp	/^int Reactor :: epoll_add_event(Event * ev)$/;"	f	class:Reactor
epoll_dispatch	reactor.cpp	/^int Reactor :: epoll_dispatch(int status,$/;"	f	class:Reactor
ev_active	event.h	/^        int ev_active;$/;"	m	class:Event
ev_arg	event.h	/^        void *ev_arg;$/;"	m	class:Event
ev_callback	event.h	/^        ev_handle ev_callback;$/;"	m	class:Event
ev_events	event.h	/^        short ev_events;$/;"	m	class:Event
ev_fd	event.h	/^        int ev_fd;$/;"	m	class:Event
ev_flags	event.h	/^        int ev_flags;$/;"	m	class:Event
ev_handle	event.h	/^typedef void (*ev_handle)(int, short, void *);$/;"	t
ev_list	reactor.h	/^        list<Event *> ev_list;$/;"	m	class:Reactor
ev_pos	event.h	/^        list<Event *>::iterator ev_pos;$/;"	m	class:Event
ev_reactor	event.h	/^        Reactor * ev_reactor;$/;"	m	class:Event
event_count	reactor.h	/^        int event_count;$/;"	m	class:Reactor
event_count_ac	reactor.h	/^        int event_count_ac;$/;"	m	class:Reactor
event_mutex	reactor.h	/^    pthread_mutex_t event_mutex; $/;"	m	class:Reactor
event_queue_insert	reactor.cpp	/^void Reactor :: event_queue_insert(Event *ev,$/;"	f	class:Reactor
events	reactor.h	/^        struct epoll_event *events;$/;"	m	class:Reactor	typeref:struct:Reactor::epoll_event
evepoll	reactor.h	/^struct evepoll$/;"	s
evread	reactor.h	/^    Event * evread;$/;"	m	struct:evepoll
evwrite	reactor.h	/^    Event * evwrite;$/;"	m	struct:evepoll
excute	event.cpp	/^void Event :: excute(void * arg)$/;"	f	class:Event
excute	event.cpp	/^void ReadEvent :: excute(void * arg)$/;"	f	class:ReadEvent
excute	event.cpp	/^void WriteEvent :: excute(void * arg)$/;"	f	class:WriteEvent
expire_timer_ms	commonn/timer.cpp	/^Timer :: expire_timer_ms()$/;"	f	class:Timer
fd	nf_server_core.h	/^    int fd;$/;"	m	struct:_nf_server_pdata_t
fds	reactor.h	/^        struct evepoll * fds; $/;"	m	class:Reactor	typeref:struct:Reactor::evepoll
find_line	net.cpp	/^find_line(char * req, int end)$/;"	f
fp	commonn/asynLog.cpp	/^FILE * Log :: fp; $/;"	m	class:Log	file:
fp	commonn/asynLog.h	/^    static FILE * fp; $/;"	m	class:Log
free_list	commonn/memCache.cpp	/^Allocate :: obj * Allocate :: free_list[LISTS] = $/;"	m	class:Allocate	file:
free_list	commonn/memCache.h	/^    static obj * free_list[LISTS];$/;"	m	class:Allocate
free_list_link	commonn/memCache.h	/^        union obj * free_list_link;$/;"	m	union:Allocate::obj	typeref:union:Allocate::obj::obj
front	commonn/queue.h	/^    int front;$/;"	m	struct:_queue_t
get	commonn/configParser.cpp	/^ConfigParser :: get(const std::string sectionName, const std::string keyName) const$/;"	f	class:ConfigParser
get	commonn/configParser.cpp	/^Section :: get(const std::string key) const$/;"	f	class:Section
get_cache	event.h	/^    inline void * get_cache()$/;"	f	class:ReadEvent
get_cache	event.h	/^    inline void * get_cache()$/;"	f	class:WriteEvent
get_cache_len	event.h	/^    inline int get_cache_len()$/;"	f	class:ReadEvent
get_cache_len	event.h	/^    inline int get_cache_len()$/;"	f	class:WriteEvent
get_epfd	reactor.h	/^    inline int get_epfd()$/;"	f	class:Reactor
get_ev_active	event.h	/^    inline int get_ev_active()$/;"	f	class:Event
get_ev_count	reactor.h	/^    inline int get_ev_count()$/;"	f	class:Reactor
get_ev_events	event.h	/^    inline int get_ev_events()$/;"	f	class:Event
get_ev_fd	event.h	/^    inline int get_ev_fd()$/;"	f	class:Event
get_ev_flags	event.h	/^    inline int get_ev_flags()$/;"	f	class:Event
get_ev_pos	event.h	/^    inline list<Event *>::iterator get_ev_pos()$/;"	f	class:Event
get_fds	reactor.h	/^    inline evepoll * get_fds()$/;"	f	class:Reactor
get_file	commonn/asynLog.h	/^    static FILE * get_file()$/;"	f	class:Log
get_pdata	nf_server_core.cpp	/^get_pdata()$/;"	f
get_reactor	event.h	/^    inline Reactor * get_reactor()$/;"	f	class:Event
get_server_data	nf_server.cpp	/^nf_server_t * NfServer :: get_server_data()$/;"	f	class:NfServer
get_tcp_sockaddr	net.cpp	/^get_tcp_sockaddr(char * addr, int * port, $/;"	f
get_time_msec	commonn/timer.cpp	/^Timer :: get_time_msec(const struct timeval * tv)$/;"	f	class:Timer
id	nf_server_core.h	/^    size_t id;$/;"	m	struct:_nf_server_pdata_t
idx	nf_server_core.h	/^    int idx; \/\/sapool, handle socket index$/;"	m	struct:_nf_server_pdata_t
init	commonn/asynLog.cpp	/^Log :: init(const char * name)$/;"	f	class:Log
init	commonn/memCache.cpp	/^Allocate :: init()$/;"	f	class:Allocate
init	event.h	/^    inline void init(int fd, $/;"	f	class:Event
init	event.h	/^    inline void init(int fd,$/;"	f	class:ReadEvent
init	event.h	/^    inline void init(int fd,$/;"	f	class:WriteEvent
init	reactor.cpp	/^int Reactor :: init(int files)$/;"	f	class:Reactor
instance	commonn/singleton.h	/^        static T * instance()$/;"	f	class:Singleton
is_empty_q	commonn/queue.cpp	/^int is_empty_q(queue_t *q)$/;"	f
is_full_q	commonn/queue.cpp	/^int is_full_q(queue_t *q)$/;"	f
items	commonn/configParser.h	/^        std::map<std::string, std::string> items;$/;"	m	class:Section
join	nf_server.cpp	/^int NfServer :: join()$/;"	f	class:NfServer
last_active	sapool.h	/^    time_t last_active;$/;"	m	struct:_sapool_sock_item_t
lf_main	lfpool.cpp	/^LfServer :: lf_main(void * param)$/;"	f	class:LfServer
lf_pool	lfpool.cpp	/^lfpool_t * LfServer :: lf_pool = NULL;$/;"	m	class:LfServer	file:
lf_pool	lfpool.h	/^        static lfpool_t * lf_pool;        $/;"	m	class:LfServer
lfpool_once_op	lfpool.cpp	/^LfServer :: lfpool_once_op(int epfd, int fd, int timeout)$/;"	f	class:LfServer
lfpool_t	lfpool.h	/^} lfpool_t;$/;"	t	typeref:struct:_lfpool_t
list_mutex	reactor.h	/^    pthread_mutex_t list_mutex;$/;"	m	class:Reactor
listen_port	nf_server_core.h	/^    size_t listen_port;$/;"	m	struct:_nf_server_t
listen_prio	nf_server_core.h	/^    size_t listen_prio; \/\/sapool$/;"	m	struct:_nf_server_t
lock	commonn/singleton.h	/^        void lock()$/;"	f	class:MutexLock
lock	lfpool.h	/^    pthread_mutex_t lock;$/;"	m	struct:_lfpool_t
log_buffer	commonn/asynLog.cpp	/^queue<string> Log :: log_buffer;$/;"	m	class:Log	file:
log_buffer	commonn/asynLog.h	/^    static queue<string> log_buffer;   $/;"	m	class:Log
log_cond	commonn/asynLog.cpp	/^pthread_cond_t Log:: log_cond;$/;"	m	class:Log	file:
log_cond	commonn/asynLog.h	/^    static pthread_cond_t  log_cond;$/;"	m	class:Log
log_mutex	commonn/asynLog.cpp	/^pthread_mutex_t Log :: log_mutex;$/;"	m	class:Log	file:
log_mutex	commonn/asynLog.h	/^    static pthread_mutex_t log_mutex;$/;"	m	class:Log
mSections	commonn/configParser.h	/^    std::map<std::string, Section> mSections;$/;"	m	class:ConfigParser
main	rapool.h	/^    pthread_t main;$/;"	m	struct:_rapool_t
main	sapool.h	/^    pthread_t main;$/;"	m	struct:_sapool_t
main	test/case/getline/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getline/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getn/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getn/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	testUnit/main.cpp	/^int main()$/;"	f
max	test/case/getline/client_simple.cpp	15;"	d	file:
max	test/case/getline/server_simple.cpp	14;"	d	file:
max	test/case/getn/client_simple.cpp	15;"	d	file:
max	test/case/getn/server_simple.cpp	14;"	d	file:
max	test/client_simple.cpp	15;"	d	file:
max	test/server_simple.cpp	14;"	d	file:
mem_mutex	commonn/memCache.cpp	/^pthread_mutex_t Allocate :: mem_mutex[LISTS];$/;"	m	class:Allocate	file:
mem_mutex	commonn/memCache.h	/^    static pthread_mutex_t mem_mutex[LISTS];$/;"	m	class:Allocate
move_forward	net.cpp	/^move_forward(char * req, int start, int end)$/;"	f
mutex	commonn/singleton.h	/^        pthread_mutex_t mutex;$/;"	m	class:MutexLock
name	nf_server_core.h	/^    char name[256];$/;"	m	struct:_nf_server_t
need_join	nf_server_core.h	/^    size_t need_join;$/;"	m	struct:_nf_server_t
net_accept	net.cpp	/^net_accept(int sockfd, struct sockaddr *sa, socklen_t * addrlen)$/;"	f
net_connect_to_ms	net.cpp	/^net_connect_to_ms(int sockfd, struct sockaddr *sa, $/;"	f
net_connect_to_tv	net.cpp	/^net_connect_to_tv(int fd, struct sockaddr * sa, $/;"	f
net_ep_add	net.cpp	/^net_ep_add(int epfd, $/;"	f
net_ep_add_in	net.cpp	/^net_ep_add_in(int epfd, int fd)$/;"	f
net_ep_add_in1	net.cpp	/^net_ep_add_in1(int epfd, int fd)$/;"	f
net_ep_create	net.cpp	/^net_ep_create(int size)$/;"	f
net_ep_del	net.cpp	/^net_ep_del(int epfd, int fd)$/;"	f
net_tcplisten	net.cpp	/^net_tcplisten(int port, int queue)$/;"	f
nevents	reactor.h	/^        int nevents;$/;"	m	class:Reactor
nevents	testUnit/main.cpp	/^const int nevents = 10;$/;"	v
next_check_time	rapool.h	/^    time_t next_check_time;$/;"	m	struct:_rapool_t
next_check_time	sapool.h	/^    time_t next_check_time;$/;"	m	struct:_sapool_t
nf_callback_proc	nf_server_core.h	/^typedef int (* nf_callback_proc)(void *req);$/;"	t
nf_default_handle	nf_server_app.cpp	/^nf_default_handle()$/;"	f
nf_handle_t	nf_server_core.h	/^typedef void (* nf_handle_t)();$/;"	t
nf_pdata_init	nf_server_core.cpp	/^nf_pdata_init(nf_server_pdata_t * pdata, nf_server_t * sev)$/;"	f
nf_server_bind	nf_server_core.cpp	/^int nf_server_bind(nf_server_t * sev)$/;"	f
nf_server_create	nf_server_core.cpp	/^nf_server_create(const char * sev_name)$/;"	f
nf_server_get_qsize	nf_server_core.cpp	/^nf_server_get_qsize(nf_server_t * sev)$/;"	f
nf_server_get_read_buf	nf_server_core.cpp	/^nf_server_get_read_buf()$/;"	f
nf_server_get_readed_size	nf_server_core.cpp	/^nf_server_get_readed_size()$/;"	f
nf_server_get_readto	nf_server_core.cpp	/^nf_server_get_readto()$/;"	f
nf_server_get_socksize	nf_server_core.cpp	/^nf_server_get_socksize(nf_server_t * sev)$/;"	f
nf_server_get_thread_epfd	nf_server_core.cpp	/^nf_server_get_thread_epfd()$/;"	f
nf_server_get_thread_id	nf_server_core.cpp	/^nf_server_get_thread_id()$/;"	f
nf_server_get_write_buf	nf_server_core.cpp	/^nf_server_get_write_buf()$/;"	f
nf_server_get_writed_size	nf_server_core.cpp	/^nf_server_get_writed_size()$/;"	f
nf_server_get_writeto	nf_server_core.cpp	/^nf_server_get_writeto()$/;"	f
nf_server_init	nf_server_core.cpp	/^nf_server_init(nf_server_t * sev)$/;"	f
nf_server_pdata_t	nf_server_core.h	/^typedef struct _nf_server_pdata_t nf_server_pdata_t;$/;"	t	typeref:struct:_nf_server_pdata_t
nf_server_set_writed_size	nf_server_core.cpp	/^nf_server_set_writed_size(int n)$/;"	f
nf_server_set_writed_start	nf_server_core.cpp	/^nf_server_set_writed_start(int n)$/;"	f
nf_server_t	nf_server_core.h	/^typedef struct _nf_server_t nf_server_t;$/;"	t	typeref:struct:_nf_server_t
nfile	reactor.h	/^        int nfile;$/;"	m	class:Reactor
obj	commonn/memCache.h	/^    union obj$/;"	u	class:Allocate
operator =	event.h	/^        Event & operator=(Event & ev)$/;"	f	class:Event
p_end	nf_server_core.h	/^    nf_handle_t p_end;    $/;"	m	struct:_nf_server_t
p_handle	nf_server_core.h	/^    nf_handle_t p_handle;    $/;"	m	struct:_nf_server_t
p_start	nf_server_core.h	/^    nf_handle_t p_start;     $/;"	m	struct:_nf_server_t
parser_file	commonn/configParser.cpp	/^ConfigParser :: parser_file(const std::string &file)$/;"	f	class:ConfigParser
pause	nf_server.cpp	/^int NfServer :: pause()$/;"	f	class:NfServer
pdata	nf_server_core.h	/^    nf_server_pdata_t * pdata;$/;"	m	struct:_nf_server_t
pid	nf_server_core.h	/^    pthread_t pid;$/;"	m	struct:_nf_server_pdata_t
pkey	nf_server_core.cpp	/^static pthread_key_t pkey;$/;"	v	file:
ponce	nf_server_core.cpp	/^static pthread_once_t ponce = PTHREAD_ONCE_INIT;$/;"	v	file:
pool	nf_server_core.h	/^    void * pool;$/;"	m	struct:_nf_server_t
pop_q	commonn/queue.cpp	/^int pop_q(queue_t *q, int *val)$/;"	f
produce_log	commonn/asynLog.cpp	/^Log :: produce_log(int event, const char * fmt, va_list args)$/;"	f	class:Log
pthread_key_del	nf_server_core.cpp	/^pthread_key_del(void)$/;"	f
pthread_num	nf_server_core.h	/^    size_t pthread_num;        \/\/Ïß³Ì³Ø¿ªÆôÏß³Ì×ÜÊý$/;"	m	struct:_nf_server_t
push_q	commonn/queue.cpp	/^int push_q(queue_t *q, int val)$/;"	f
qsize	nf_server_core.h	/^    size_t qsize; \/\/sapool$/;"	m	struct:_nf_server_t
queue	sapool.h	/^    queue_t queue;$/;"	m	struct:_sapool_t
queue_t	commonn/queue.h	/^typedef struct _queue_t queue_t;$/;"	t	typeref:struct:_queue_t
ra_pool	rapool.h	/^       static rapool_t * ra_pool; $/;"	m	class:RaServer
rapool_add	rapool.cpp	/^RaServer :: rapool_add(nf_server_t * sev, int sock, struct sockaddr_in *addr)$/;"	f	class:RaServer
rapool_close_pool_sockets	rapool.cpp	/^RaServer :: rapool_close_pool_sockets(nf_server_t *sev, bool is_listenfd)$/;"	f	class:RaServer
rapool_del	rapool.cpp	/^RaServer :: rapool_del(nf_server_t *sev, int idx, int alive, bool remove)$/;"	f	class:RaServer
rapool_epoll_add_read	rapool.cpp	/^RaServer :: rapool_epoll_add_read(nf_server_t *sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_epoll_del	rapool.cpp	/^RaServer :: rapool_epoll_del(nf_server_t * sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_epoll_mod_read	rapool.cpp	/^RaServer :: rapool_epoll_mod_read(nf_server_t *sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_epoll_mod_write	rapool.cpp	/^RaServer :: rapool_epoll_mod_write(nf_server_t *sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_main	rapool.cpp	/^RaServer :: rapool_main(void *param)$/;"	f	class:RaServer
rapool_produce	rapool.cpp	/^RaServer :: rapool_produce(nf_server_t * sev, $/;"	f	class:RaServer
rapool_reactor	rapool.cpp	/^RaServer :: rapool_reactor(rapool_t * pool, nf_server_pdata_t * pdata)$/;"	f	class:RaServer
rapool_sock_item_t	rapool.h	/^typedef struct _rapool_sock_item_t rapool_sock_item_t;$/;"	t	typeref:struct:_rapool_sock_item_t
rapool_t	rapool.h	/^typedef struct _rapool_t rapool_t;$/;"	t	typeref:struct:_rapool_t
rapool_t	rapool.h	/^}rapool_t;$/;"	t	typeref:struct:_rapool_t
rapool_workers	rapool.cpp	/^RaServer :: rapool_workers(void * param)$/;"	f	class:RaServer
read_buf	nf_server_core.h	/^    void *read_buf;$/;"	m	struct:_nf_server_pdata_t
read_size	nf_server_core.h	/^    size_t read_size;$/;"	m	struct:_nf_server_pdata_t
read_start	nf_server_core.h	/^    int read_start;$/;"	m	struct:_nf_server_pdata_t
read_to	nf_server_core.h	/^    size_t read_to;$/;"	m	struct:_nf_server_t
readed_size	nf_server_core.h	/^    size_t readed_size;$/;"	m	struct:_nf_server_pdata_t
readn	net.cpp	/^readn(int fd, void *usrbuf, size_t n)$/;"	f
readn_to_ms	net.cpp	/^readn_to_ms(int fd, void *ptr, size_t nbytes, int msecs)$/;"	f
ready_cond	sapool.h	/^    pthread_cond_t  ready_cond;$/;"	m	struct:_sapool_t
ready_mutex	sapool.h	/^    pthread_mutex_t ready_mutex;$/;"	m	struct:_sapool_t
rear	commonn/queue.h	/^    int rear;$/;"	m	struct:_queue_t
refill	commonn/memCache.cpp	/^Allocate :: refill(size_t n)$/;"	f	class:Allocate
resume	nf_server.cpp	/^int NfServer :: resume()$/;"	f	class:NfServer
rio	nf_server_core.h	/^    rio_t rio;$/;"	m	struct:_nf_server_pdata_t
rio_bufptr	net.h	/^    char * rio_bufptr;\/\/ ½¨ÒéÖ±½Ó¶Áµ½Ïß³Ì¹¤×÷¿¿Õ¼ä $/;"	m	struct:_rio_t
rio_cnt	net.h	/^    int rio_cnt;      \/\/ ÄÚÖÃ·â×°readÊ±Ê¹ÓÃ$/;"	m	struct:_rio_t
rio_fd	net.h	/^    int rio_fd;$/;"	m	struct:_rio_t
rio_init	net.cpp	/^void rio_init(rio_t *rp, int fd, int len)$/;"	f
rio_len	net.h	/^    size_t rio_len;   \/\/ ²»½¨ÒéÊ¹ÓÃ·â×°read²Ù×÷$/;"	m	struct:_rio_t
rio_ptr	net.h	/^    char * rio_ptr;   $/;"	m	struct:_rio_t
rio_read	net.cpp	/^rio_read(rio_t *rp, char *usrbuf, size_t n)$/;"	f	file:
rio_readline	net.cpp	/^rio_readline(rio_t *rp, void *usrbuf, size_t maxlen, int * st)$/;"	f
rio_readline_to_ms	net.cpp	/^rio_readline_to_ms(rio_t *rp, void *usrbuf, size_t maxlen, int msecs)$/;"	f
rio_readn	net.cpp	/^rio_readn(rio_t *rp, void *usrbuf, size_t n, int * st)$/;"	f
rio_readn_to_ms	net.cpp	/^rio_readn_to_ms(rio_t *rp, void *usrbuf, size_t n, int msecs)$/;"	f
rio_t	net.h	/^} rio_t;$/;"	t	typeref:struct:_rio_t
rp	rapool.h	/^    rio_t rp;$/;"	m	struct:_rapool_sock_item_t
rp	sapool.h	/^    rio_t rp;$/;"	m	struct:_sapool_sock_item_t
run	nf_server.cpp	/^int NfServer :: run()$/;"	f	class:NfServer
run	nf_server_core.h	/^    int run;     $/;"	m	struct:_nf_server_t
run	rapool.h	/^    int * run;$/;"	m	struct:_rapool_t
run	reactor.h	/^        bool run;$/;"	m	class:Reactor
run	sapool.h	/^    int * run;$/;"	m	struct:_sapool_t
run_thread_num	nf_server_core.h	/^    int run_thread_num;        \/\/¹¤×÷Ïß³ÌÊý$/;"	m	struct:_nf_server_t
sa_pool	sapool.h	/^        static sapool_t * sa_pool;        $/;"	m	class:SaServer
sapool_add	sapool.cpp	/^SaServer :: sapool_add(nf_server_t * sev, int sock, struct sockaddr_in *addr)$/;"	f	class:SaServer
sapool_check_timeout	sapool.cpp	/^SaServer :: sapool_check_timeout(nf_server_t *sev)$/;"	f	class:SaServer
sapool_close_pool_sockets	sapool.cpp	/^SaServer :: sapool_close_pool_sockets(nf_server_t *sev, bool is_listenfd)$/;"	f	class:SaServer
sapool_consume	sapool.cpp	/^SaServer :: sapool_consume(sapool_t * pool, nf_server_pdata_t * pdata)$/;"	f	class:SaServer
sapool_del	sapool.cpp	/^SaServer :: sapool_del(nf_server_t *sev, int idx, int alive, bool remove)$/;"	f	class:SaServer
sapool_epoll_add	sapool.cpp	/^SaServer :: sapool_epoll_add(nf_server_t *sev, int idx)$/;"	f	class:SaServer
sapool_epoll_del	sapool.cpp	/^SaServer :: sapool_epoll_del(nf_server_t *sev, int idx)$/;"	f	class:SaServer
sapool_get	sapool.cpp	/^SaServer :: sapool_get(nf_server_t *sev, int *idx)$/;"	f	class:SaServer
sapool_get_queuenum	sapool.cpp	/^SaServer :: sapool_get_queuenum(nf_server_t *sev)$/;"	f	class:SaServer
sapool_main	sapool.cpp	/^SaServer :: sapool_main(void *param)$/;"	f	class:SaServer
sapool_produce	sapool.cpp	/^SaServer :: sapool_produce(nf_server_t * sev, struct sockaddr * addr, $/;"	f	class:SaServer
sapool_pthread_cond_timewait	sapool.cpp	/^SaServer :: sapool_pthread_cond_timewait(sapool_t *pool)$/;"	f	class:SaServer
sapool_put	sapool.cpp	/^SaServer :: sapool_put(sapool_t *pool, int idx)$/;"	f	class:SaServer
sapool_sock_item_t	sapool.h	/^typedef struct _sapool_sock_item_t sapool_sock_item_t;$/;"	t	typeref:struct:_sapool_sock_item_t
sapool_t	sapool.h	/^typedef struct _sapool_t sapool_t;$/;"	t	typeref:struct:_sapool_t
sapool_workers	sapool.cpp	/^SaServer :: sapool_workers(void * param)$/;"	f	class:SaServer
scan	commonn/configParser.cpp	/^ConfigParser :: scan() const$/;"	f	class:ConfigParser
scan	commonn/configParser.cpp	/^Section :: scan() const$/;"	f	class:Section
sendn	net.cpp	/^sendn(int fd, void *usrbuf, size_t n)$/;"	f
sendn_to_ms	net.cpp	/^sendn_to_ms(int fd, const void *ptr, size_t nbytes, int msecs)$/;"	f
server	nf_server_core.h	/^    nf_server_t *server;$/;"	m	struct:_nf_server_pdata_t
server_type	nf_server_core.h	/^    size_t server_type;$/;"	m	struct:_nf_server_t
set	commonn/configParser.h	/^        inline void set(const std::string &key, const std::string &val)$/;"	f	class:Section
set	commonn/configParser.h	/^    inline void set(const std::string &sectionName, const std::string &keyName, $/;"	f	class:ConfigParser
set_cache_len	event.h	/^    inline void set_cache_len(int len)$/;"	f	class:ReadEvent
set_cache_len	event.h	/^    inline void set_cache_len(int len)$/;"	f	class:WriteEvent
set_clc_fd	net.cpp	/^set_clc_fd(int fd, int flags)$/;"	f
set_ev_flags	event.h	/^    inline void set_ev_flags(int flg)$/;"	f	class:Event
set_event_active	reactor.cpp	/^bool Reactor :: set_event_active(Event * ev)$/;"	f	class:Reactor
set_event_unactive	reactor.cpp	/^bool Reactor :: set_event_unactive(Event * ev)$/;"	f	class:Reactor
set_fd	net.cpp	/^set_fd(int fd, int flags)$/;"	f
set_fd_block	net.cpp	/^set_fd_block(int fd)$/;"	f
set_fd_noblock	net.cpp	/^set_fd_noblock(int fd)$/;"	f
set_file	commonn/asynLog.h	/^    static void set_file(FILE * file)$/;"	f	class:Log
set_handle	nf_server.cpp	/^int NfServer :: set_handle( nf_handle_t handle ) $/;"	f	class:NfServer
set_level	commonn/asynLog.h	/^    static void set_level(int level)$/;"	f	class:Log
set_linger	net.cpp	/^set_linger(int fd, int val)$/;"	f
set_pthread_data	nf_server_core.cpp	/^set_pthread_data(nf_server_pdata_t *data)$/;"	f
set_server_name	nf_server.cpp	/^int NfServer :: set_server_name(const char * sev_name)$/;"	f	class:NfServer
set_server_startfun	nf_server.cpp	/^int NfServer :: set_server_startfun( nf_handle_t start )$/;"	f	class:NfServer
set_sev_socketopt	nf_server_core.cpp	/^int set_sev_socketopt(nf_server_t *sev, int fd)$/;"	f
set_status	commonn/asynLog.h	/^    static void set_status(int status)$/;"	f	class:Log
set_tcp_sockaddr	net.cpp	/^set_tcp_sockaddr(char * addr, int port, $/;"	f
set_thread_endfun	nf_server.cpp	/^int NfServer :: set_thread_endfun( nf_handle_t end )$/;"	f	class:NfServer
set_thread_startfun	nf_server.cpp	/^int NfServer :: set_thread_startfun( nf_handle_t start ) $/;"	f	class:NfServer
set_work_callback	nf_server.cpp	/^int NfServer :: set_work_callback(BaseWork * run)$/;"	f	class:NfServer
sev_data	nf_server.h	/^        nf_server_t *sev_data; \/\/server ºËÐÄÊý¾Ý½á¹¹$/;"	m	class:NfServer
sev_sock_id	rapool.h	/^    int sev_sock_id;$/;"	m	struct:_rapool_t
sev_sock_id	sapool.h	/^    int sev_sock_id;$/;"	m	struct:_sapool_t
sev_socket	nf_server_core.h	/^    int sev_socket; $/;"	m	struct:_nf_server_t
size	commonn/queue.h	/^    int size;$/;"	m	struct:_queue_t
size	rapool.h	/^    int size;$/;"	m	struct:_rapool_t
size	sapool.h	/^    int size;$/;"	m	struct:_sapool_t
sock	rapool.h	/^    int sock;$/;"	m	struct:_rapool_sock_item_t
sock	sapool.h	/^    int sock;$/;"	m	struct:_sapool_sock_item_t
sock_family	nf_server_core.h	/^    int sock_family;$/;"	m	struct:_nf_server_t
sock_timeout	rapool.h	/^    long long sock_timeout;    $/;"	m	struct:_rapool_sock_item_t
sockets	rapool.h	/^    rapool_sock_item_t * sockets;$/;"	m	struct:_rapool_t
sockets	sapool.h	/^    sapool_sock_item_t * sockets;$/;"	m	struct:_sapool_t
socksize	nf_server_core.h	/^    size_t socksize;  \/\/sapool$/;"	m	struct:_nf_server_t
stack_size	nf_server_core.h	/^    size_t stack_size; \/\/Ïß³ÌÕ»´óÐ¡$/;"	m	struct:_nf_server_t
start	reactor.cpp	/^int Reactor :: start(int status)$/;"	f	class:Reactor
status	nf_server_core.h	/^    SERVER_STATUS_T status;$/;"	m	struct:_nf_server_t
status	rapool.h	/^    int status;$/;"	m	struct:_rapool_sock_item_t
status	reactor.h	/^    int status;$/;"	m	struct:evepoll
status	sapool.h	/^    int status;$/;"	m	struct:_sapool_sock_item_t
stop	commonn/asynLog.h	/^    static void stop()$/;"	f	class:Log
stop	nf_server.cpp	/^int NfServer :: stop()$/;"	f	class:NfServer
str_prefix	commonn/asynLog.cpp	/^string Log :: str_prefix[4] = {"[DEBUG]  ", $/;"	m	class:Log	file:
str_prefix	commonn/asynLog.h	/^    static string str_prefix[4];$/;"	m	class:Log
stratgy	nf_server_core.h	/^    BaseWork * stratgy;$/;"	m	struct:_nf_server_t
svr	factory.h	/^static struct NfServer * svr[] = $/;"	v	typeref:struct:NfServer
svr_destroy	lfpool.cpp	/^LfServer :: svr_destroy()$/;"	f	class:LfServer
svr_destroy	rapool.cpp	/^RaServer :: svr_destroy()$/;"	f	class:RaServer
svr_destroy	sapool.cpp	/^SaServer :: svr_destroy()$/;"	f	class:SaServer
svr_init	lfpool.cpp	/^LfServer :: svr_init()$/;"	f	class:LfServer
svr_init	rapool.cpp	/^RaServer :: svr_init()$/;"	f	class:RaServer
svr_init	sapool.cpp	/^SaServer :: svr_init()$/;"	f	class:SaServer
svr_join	lfpool.cpp	/^LfServer :: svr_join()$/;"	f	class:LfServer
svr_join	rapool.cpp	/^RaServer :: svr_join()$/;"	f	class:RaServer
svr_join	sapool.cpp	/^SaServer :: svr_join()$/;"	f	class:SaServer
svr_listen	lfpool.cpp	/^LfServer :: svr_listen()$/;"	f	class:LfServer
svr_listen	rapool.cpp	/^RaServer :: svr_listen()$/;"	f	class:RaServer
svr_listen	sapool.cpp	/^SaServer :: svr_listen()$/;"	f	class:SaServer
svr_pause	lfpool.cpp	/^LfServer :: svr_pause()$/;"	f	class:LfServer
svr_pause	rapool.cpp	/^RaServer :: svr_pause()$/;"	f	class:RaServer
svr_pause	sapool.cpp	/^SaServer :: svr_pause()$/;"	f	class:SaServer
svr_resume	lfpool.cpp	/^LfServer :: svr_resume()$/;"	f	class:LfServer
svr_resume	rapool.cpp	/^RaServer :: svr_resume()$/;"	f	class:RaServer
svr_resume	sapool.cpp	/^SaServer :: svr_resume()$/;"	f	class:SaServer
svr_run	lfpool.cpp	/^LfServer :: svr_run()$/;"	f	class:LfServer
svr_run	rapool.cpp	/^RaServer :: svr_run()$/;"	f	class:RaServer
svr_run	sapool.cpp	/^SaServer :: svr_run()$/;"	f	class:SaServer
svr_set_stragy	lfpool.cpp	/^LfServer :: svr_set_stragy(BaseWork * sta)$/;"	f	class:LfServer
svr_set_stragy	rapool.cpp	/^RaServer :: svr_set_stragy(BaseWork * sta)$/;"	f	class:RaServer
svr_set_stragy	sapool.cpp	/^SaServer :: svr_set_stragy( BaseWork * sta)$/;"	f	class:SaServer
svr_type	factory.h	/^        int svr_type;$/;"	m	class:Factory
test_fun	testUnit/main.cpp	/^void test_fun(int fd, short events, void * arg)$/;"	f
thread_read_buf	nf_server_core.h	/^    size_t thread_read_buf;$/;"	m	struct:_nf_server_t
thread_usr_buf	nf_server_core.h	/^    size_t thread_usr_buf;$/;"	m	struct:_nf_server_t
thread_write_buf	nf_server_core.h	/^    size_t thread_write_buf;$/;"	m	struct:_nf_server_t
timeout	nf_server_core.h	/^    size_t timeout; \/\/sapool$/;"	m	struct:_nf_server_t
timeout	rapool.h	/^    int timeout;        \/\/epollµÄ³¬Ê±Ê±¼ä$/;"	m	struct:_rapool_t
timeout	sapool.h	/^    int timeout;        \/\/epollµÄ³¬Ê±Ê±¼ä$/;"	m	struct:_sapool_t
timer	commonn/timer.h	/^        multimap<long long, pair<timer_callback_proc, void *> > timer;$/;"	m	class:Timer
timer	nf_server_core.h	/^    Timer timer;$/;"	m	struct:_nf_server_pdata_t
timer_callback_proc	commonn/timer.h	/^        typedef int (* timer_callback_proc)(void * param);$/;"	t	class:Timer
top_timer_ms	commonn/timer.cpp	/^Timer :: top_timer_ms()$/;"	f	class:Timer
unlock	commonn/singleton.h	/^        void unlock()$/;"	f	class:MutexLock
using_size	rapool.h	/^    long long using_size;$/;"	m	struct:_rapool_t
using_size	sapool.h	/^    long long using_size;$/;"	m	struct:_sapool_t
usr_buf	nf_server_core.h	/^    void *usr_buf;$/;"	m	struct:_nf_server_pdata_t
usr_size	nf_server_core.h	/^    size_t usr_size;$/;"	m	struct:_nf_server_pdata_t
w_allo_cache	net.h	/^    char * w_allo_cache;$/;"	m	struct:_rio_t
w_allo_len	net.h	/^    int w_allo_len;    $/;"	m	struct:_rio_t
w_cache	net.h	/^    char * w_cache;$/;"	m	struct:_rio_t
w_cache_len	net.h	/^    int w_cache_len;$/;"	m	struct:_rio_t
work	nf_server_app.cpp	/^LfReadLine :: work(void * data)$/;"	f	class:LfReadLine
work	nf_server_app.cpp	/^RaReadLine :: work(void * data)$/;"	f	class:RaReadLine
work	nf_server_app.cpp	/^SaReadLine :: work(void * data)$/;"	f	class:SaReadLine
work	test/case/getline/client_simple.cpp	/^void * work(void * arg)$/;"	f
work	test/case/getn/client_simple.cpp	/^void * work(void * arg)$/;"	f
work	test/client_simple.cpp	/^void * work(void * arg)$/;"	f
work_prio	nf_server_core.h	/^    size_t work_prio;   \/\/sapool$/;"	m	struct:_nf_server_t
write_buf	nf_server_core.h	/^    void *write_buf;$/;"	m	struct:_nf_server_pdata_t
write_log	commonn/asynLog.cpp	/^Log :: write_log(void *)$/;"	f	class:Log
write_size	nf_server_core.h	/^    size_t write_size;$/;"	m	struct:_nf_server_pdata_t
write_start	nf_server_core.h	/^    int write_start;$/;"	m	struct:_nf_server_pdata_t
write_to	nf_server_core.h	/^    size_t write_to;$/;"	m	struct:_nf_server_t
writed_size	nf_server_core.h	/^    size_t writed_size;$/;"	m	struct:_nf_server_pdata_t
~BaseWork	nf_server_core.h	/^        virtual ~BaseWork(){};$/;"	f	class:BaseWork
~ConfigParser	commonn/configParser.h	/^        virtual ~ConfigParser(){}$/;"	f	class:ConfigParser
~Factory	factory.h	/^        virtual ~Factory(){};$/;"	f	class:Factory
~LfBaseWork	nf_server_app.h	/^        virtual ~LfBaseWork(){};$/;"	f	class:LfBaseWork
~LfReadLine	nf_server_app.h	/^        virtual ~LfReadLine(){};$/;"	f	class:LfReadLine
~LfServer	lfpool.h	/^        virtual ~LfServer(){};$/;"	f	class:LfServer
~MutexLock	commonn/singleton.h	/^        ~MutexLock()$/;"	f	class:MutexLock
~NfServer	nf_server.cpp	/^NfServer :: ~NfServer()$/;"	f	class:NfServer
~RaBaseWork	nf_server_app.h	/^        virtual ~RaBaseWork(){};$/;"	f	class:RaBaseWork
~RaReadLine	nf_server_app.h	/^        virtual ~RaReadLine(){};$/;"	f	class:RaReadLine
~RaServer	rapool.h	/^        virtual ~RaServer(){};$/;"	f	class:RaServer
~SaBaseWork	nf_server_app.h	/^        virtual ~SaBaseWork(){};$/;"	f	class:SaBaseWork
~SaReadLine	nf_server_app.h	/^        virtual ~SaReadLine(){};$/;"	f	class:SaReadLine
~SaServer	sapool.h	/^        virtual ~SaServer(){};$/;"	f	class:SaServer
~Server	commonn/Server.h	/^        virtual ~Server(){};$/;"	f	class:Server
