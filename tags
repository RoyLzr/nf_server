!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALIGN	commonn/memCache.h	/^enum {ALIGN = 8};$/;"	e	enum:__anon1
Allocate	commonn/memCache.h	/^class Allocate$/;"	c
BUFLEN	test/case/getline/server_simple.cpp	15;"	d	file:
BUFLEN	test/case/getn/server_simple.cpp	15;"	d	file:
BUFLEN	test/server_simple.cpp	14;"	d	file:
BUSY	rapool.cpp	/^    BUSY$/;"	e	enum:__anon11	file:
BUSY	sapool.cpp	/^    BUSY$/;"	e	enum:__anon13	file:
CHUNK_NODE	commonn/memCache.h	/^enum {CHUNK_NODE = 20};$/;"	e	enum:__anon4
ConfigParser	commonn/configParser.h	/^        ConfigParser(){}$/;"	f	class:ConfigParser
ConfigParser	commonn/configParser.h	/^class ConfigParser$/;"	c
DEBUG	commonn/asynLog.cpp	/^Log :: DEBUG(const char * fmt, ...)$/;"	f	class:Log
DEFAULT_CHECK_INTERVAL	sapool.cpp	/^    DEFAULT_CHECK_INTERVAL = 10,  \/\/\/默认check_interval, 10ms$/;"	e	enum:__anon12	file:
DEFAULT_QUEUE_LEN	sapool.cpp	/^    DEFAULT_QUEUE_LEN = 100,      \/\/\/默认的等待队列的长度 100$/;"	e	enum:__anon12	file:
DEFAULT_SOCK_NUM	sapool.cpp	/^    DEFAULT_SOCK_NUM = 500,       \/\/\/同时维护的最大sock句柄数，500$/;"	e	enum:__anon12	file:
DEFAULT_TIMEOUT	sapool.cpp	/^    DEFAULT_TIMEOUT = 60,         \/\/\/等待队列里面的默认超时时间t, 60s$/;"	e	enum:__anon12	file:
ERROR	commonn/asynLog.cpp	/^Log :: ERROR(const char * fmt, ...)$/;"	f	class:Log
FREELIST_INDEX	commonn/memCache.h	/^    static size_t FREELIST_INDEX(size_t n)$/;"	f	class:Allocate
IDLE	rapool.cpp	/^    IDLE = 0,$/;"	e	enum:__anon11	file:
IDLE	sapool.cpp	/^    IDLE = 0,$/;"	e	enum:__anon13	file:
INIT	nf_server_core.h	/^    INIT    = 0,$/;"	e	enum:__anon7
LEVEL	commonn/asynLog.cpp	/^int Log :: LEVEL = LOG_DEBUG;$/;"	m	class:Log	file:
LEVEL	commonn/asynLog.h	/^    static int LEVEL;$/;"	m	class:Log
LISTENER_PRIORITY	rapool.h	6;"	d
LISTENER_PRIORITY	sapool.h	7;"	d
LISTS	commonn/memCache.h	/^enum {LISTS = MAX_BYTES\/ALIGN};$/;"	e	enum:__anon3
LOG_DEBUG	commonn/asynLog.h	/^    LOG_DEBUG,$/;"	e	enum:__anon5
LOG_ERROR	commonn/asynLog.h	/^    LOG_ERROR,$/;"	e	enum:__anon5
LOG_INIT	commonn/asynLog.h	/^    LOG_INIT,$/;"	e	enum:__anon6
LOG_MAXLINE	commonn/asynLog.h	/^    LOG_MAXLINE = 1000$/;"	e	enum:__anon5
LOG_NOTICE	commonn/asynLog.h	/^    LOG_NOTICE,$/;"	e	enum:__anon5
LOG_RUN	commonn/asynLog.h	/^    LOG_RUN,$/;"	e	enum:__anon6
LOG_STOP	commonn/asynLog.h	/^    LOG_STOP$/;"	e	enum:__anon6
LOG_WARN	commonn/asynLog.h	/^    LOG_WARN, $/;"	e	enum:__anon5
Lock	commonn/singleton.h	/^        static MutexLock Lock;$/;"	m	class:Singleton
Lock	commonn/singleton.h	/^MutexLock Singleton<T>::Lock;$/;"	m	class:Singleton
Log	commonn/asynLog.h	/^class Log$/;"	c
MAX	rapool.cpp	16;"	d	file:
MAX	sapool.cpp	18;"	d	file:
MAX_BYTES	commonn/memCache.h	/^enum {MAX_BYTES = 128};$/;"	e	enum:__anon2
MutexLock	commonn/singleton.h	/^        MutexLock()$/;"	f	class:MutexLock
MutexLock	commonn/singleton.h	/^class MutexLock$/;"	c
NFSVR_LFPOOL	nf_server_core.h	/^    NFSVR_LFPOOL = 0,    \/\/建议用于多线程短连接                                                                   $/;"	e	enum:__anon8
NFSVR_LONG_CONNEC	nf_server_core.h	/^    NFSVR_LONG_CONNEC$/;"	e	enum:__anon9
NFSVR_POOL_NUM	nf_server_core.h	/^    NFSVR_POOL_NUM,     \/\/当前有多少个pool    $/;"	e	enum:__anon8
NFSVR_RAPOOL	nf_server_core.h	/^    NFSVR_RAPOOL,        \/\/reactor + pthread IO密集，thread 数与核有关$/;"	e	enum:__anon8
NFSVR_SAPOOL	nf_server_core.h	/^    NFSVR_SAPOOL,        \/\/建议用于多线程长连接     $/;"	e	enum:__anon8
NFSVR_SHORT_CONNEC	nf_server_core.h	/^    NFSVR_SHORT_CONNEC = 0,$/;"	e	enum:__anon9
NOTICE	commonn/asynLog.cpp	/^Log :: NOTICE(const char * fmt, ...)$/;"	f	class:Log
NfServer	nf_server.cpp	/^    NfServer :: NfServer()$/;"	f	class:nf::NfServer
NfServer	nf_server.h	/^    class NfServer$/;"	c	namespace:nf
PAUSE	nf_server_core.h	/^    PAUSE   = 2,$/;"	e	enum:__anon7
RA_CHECK_INTERVAL	rapool.cpp	/^    RA_CHECK_INTERVAL = 10,  \/\/\/默认check_interval, 10ms$/;"	e	enum:__anon10	file:
RA_SOCK_NUM	rapool.cpp	/^    RA_SOCK_NUM = 500,       \/\/\/同时维护的最大sock句柄数，500$/;"	e	enum:__anon10	file:
RA_TIMEOUT	rapool.cpp	/^    RA_TIMEOUT = 60,         \/\/\/等待队列里面的默认超时时间t, 60s$/;"	e	enum:__anon10	file:
READY	sapool.cpp	/^    READY,$/;"	e	enum:__anon13	file:
ROUND_UP	commonn/memCache.h	/^    static size_t ROUND_UP(size_t n)$/;"	f	class:Allocate
RUNNING	nf_server_core.h	/^    RUNNING = 1,$/;"	e	enum:__anon7
SERVER_STATUS_T	nf_server_core.h	/^}SERVER_STATUS_T;$/;"	t	typeref:enum:__anon7
STATUS	commonn/asynLog.cpp	/^int Log :: STATUS = LOG_INIT;$/;"	m	class:Log	file:
STATUS	commonn/asynLog.h	/^    static int STATUS;   $/;"	m	class:Log
STOP	nf_server_core.h	/^    STOP    = 3$/;"	e	enum:__anon7
Section	commonn/configParser.h	/^class Section$/;"	c
Server	commonn/Server.h	/^class Server$/;"	c
Singleton	commonn/singleton.h	/^class Singleton$/;"	c
WARN	commonn/asynLog.cpp	/^Log :: WARN(const char * fmt, ...)$/;"	f	class:Log
WORKER_PRIORITY	rapool.h	7;"	d
WORKER_PRIORITY	sapool.h	8;"	d
_ASYN_LOG_	commonn/asynLog.h	2;"	d
_CONFIG_PARSER_H	commonn/configParser.h	2;"	d
_MEM_CACHE_	commonn/memCache.h	2;"	d
_NFSERVER_CORE_H	nf_server_core.h	8;"	d
_NFSERVER_REGISTER_H	pool_register.h	2;"	d
_NF_SERVER_H	nf_server.h	10;"	d
_QUEUE_H	commonn/queue.h	2;"	d
_SERVER_H	commonn/Server.h	9;"	d
__NET_H__	net.h	12;"	d
__RAPOOL_H_	rapool.h	2;"	d
__SAPOOL_H_	sapool.h	2;"	d
_initialized	commonn/singleton.h	/^        static bool _initialized;$/;"	m	class:Singleton
_initialized	commonn/singleton.h	/^bool Singleton<T>::_initialized = false;$/;"	m	class:Singleton
_instance	commonn/singleton.h	/^        static T * _instance;$/;"	m	class:Singleton
_instance	commonn/singleton.h	/^T * Singleton<T>::_instance = NULL;$/;"	m	class:Singleton
_lfpool_t	lfpool.cpp	/^typedef struct _lfpool_t $/;"	s	file:
_nf_server_pdata_t	nf_server_core.h	/^struct _nf_server_pdata_t$/;"	s
_nf_server_t	nf_server_core.h	/^struct _nf_server_t$/;"	s
_pool_t	pool_register.h	/^struct _pool_t$/;"	s
_queue_t	commonn/queue.h	/^struct _queue_t$/;"	s
_rapool_sock_item_t	rapool.h	/^struct _rapool_sock_item_t$/;"	s
_rapool_t	rapool.h	/^struct _rapool_t$/;"	s
_rio_t	net.h	/^typedef struct _rio_t$/;"	s
_sapool_sock_item_t	sapool.h	/^struct _sapool_sock_item_t$/;"	s
_sapool_t	sapool.h	/^struct _sapool_t$/;"	s
_singleton_h	commonn/singleton.h	2;"	d
add_listen_socket	rapool.cpp	/^add_listen_socket(nf_server_t *sev, int listenfd)$/;"	f	file:
add_listen_socket	sapool.cpp	/^add_listen_socket(nf_server_t *sev, int listenfd)$/;"	f	file:
add_prefix	commonn/asynLog.cpp	/^add_prefix(char * dest, const string &add)$/;"	f
addr	rapool.h	/^    struct sockaddr_in addr;$/;"	m	struct:_rapool_sock_item_t	typeref:struct:_rapool_sock_item_t::sockaddr_in
addr	sapool.h	/^    struct sockaddr_in addr;$/;"	m	struct:_sapool_sock_item_t	typeref:struct:_sapool_sock_item_t::sockaddr_in
allocate	commonn/memCache.cpp	/^Allocate :: allocate(size_t n)$/;"	f	class:Allocate
array	commonn/queue.h	/^    int *array;$/;"	m	struct:_queue_t
backlog	nf_server_core.h	/^    size_t backlog;$/;"	m	struct:_nf_server_t
buffer	commonn/asynLog.cpp	/^char Log :: buffer[LOG_MAXLINE];$/;"	m	class:Log	file:
buffer	commonn/asynLog.h	/^    static char buffer[LOG_MAXLINE];$/;"	m	class:Log
cache	net.h	/^    char * cache;$/;"	m	struct:_rio_t
cache_len	net.h	/^    int cache_len;$/;"	m	struct:_rio_t
cap	commonn/queue.h	/^    int cap;$/;"	m	struct:_queue_t
cb_work	nf_server_core.h	/^    nf_callback_proc cb_work;$/;"	m	struct:_nf_server_t
check_interval	nf_server_core.h	/^    size_t check_interval;  \/\/sapool$/;"	m	struct:_nf_server_t
check_interval	rapool.h	/^    int check_interval;    \/\/微妙级别支持超时$/;"	m	struct:_rapool_t
check_interval	sapool.h	/^    int check_interval;    \/\/微妙级别支持超时$/;"	m	struct:_sapool_t
check_socket_queue	sapool.cpp	/^int check_socket_queue(nf_server_t *sev)$/;"	f
client_addr	nf_server_core.h	/^    struct sockaddr_in client_addr;$/;"	m	struct:_nf_server_pdata_t	typeref:struct:_nf_server_pdata_t::sockaddr_in
client_data	commonn/memCache.h	/^        char client_data[1];$/;"	m	union:Allocate::obj
connect_to	nf_server_core.h	/^    size_t connect_to;$/;"	m	struct:_nf_server_t
connect_type	nf_server_core.h	/^    size_t connect_type; $/;"	m	struct:_nf_server_t
createData	test/case/getline/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
createData	test/case/getn/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
createData	test/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
create_key_once	nf_server_core.cpp	/^create_key_once(void)$/;"	f	file:
create_q	commonn/queue.cpp	/^int create_q(queue_t *q, int qcap)$/;"	f
ctime	commonn/asynLog.cpp	/^ctime(char * t_time, size_t n)$/;"	f
deallocate	commonn/memCache.cpp	/^Allocate :: deallocate(void * p, size_t n)$/;"	f	class:Allocate
default_hand	net.cpp	/^default_hand(int sig)$/;"	f
destroy	commonn/singleton.h	/^        static void destroy()$/;"	f	class:Singleton
destroy	nf_server.cpp	/^    int NfServer :: destroy()$/;"	f	class:nf::NfServer
destroy	pool_register.h	/^    destroy_pool destroy;$/;"	m	struct:_pool_t
destroy_pool	pool_register.h	/^typedef int (*destroy_pool)(nf_server_t *);$/;"	t
destroy_q	commonn/queue.cpp	/^int destroy_q(queue_t *q)$/;"	f
empty_q	commonn/queue.cpp	/^int empty_q(queue_t *q)$/;"	f
empty_str	commonn/configParser.cpp	/^static const std::string empty_str = "";$/;"	v	file:
ep_events	rapool.h	/^    struct epoll_event * ep_events;$/;"	m	struct:_rapool_t	typeref:struct:_rapool_t::epoll_event
ep_events	sapool.h	/^    struct epoll_event * ep_events;$/;"	m	struct:_sapool_t	typeref:struct:_sapool_t::epoll_event
ep_size	nf_server_core.h	/^    size_t ep_size;$/;"	m	struct:_nf_server_pdata_t
epfd	nf_server_core.h	/^    int epfd;$/;"	m	struct:_nf_server_pdata_t
epfd	nf_server_core.h	/^    int epfd;$/;"	m	struct:_nf_server_t
epfd	rapool.h	/^    int epfd;$/;"	m	struct:_rapool_t
epfd	sapool.h	/^    int epfd;$/;"	m	struct:_sapool_t
fd	nf_server_core.h	/^    int fd;$/;"	m	struct:_nf_server_pdata_t
find_line	net.cpp	/^find_line(char * req, int end)$/;"	f
fp	commonn/asynLog.cpp	/^FILE * Log :: fp; $/;"	m	class:Log	file:
fp	commonn/asynLog.h	/^    static FILE * fp; $/;"	m	class:Log
free_list	commonn/memCache.cpp	/^Allocate :: obj * Allocate :: free_list[LISTS] = $/;"	m	class:Allocate	file:
free_list	commonn/memCache.h	/^    static obj * free_list[LISTS];$/;"	m	class:Allocate
free_list_link	commonn/memCache.h	/^        union obj * free_list_link;$/;"	m	union:Allocate::obj	typeref:union:Allocate::obj::obj
front	commonn/queue.h	/^    int front;$/;"	m	struct:_queue_t
g_pool	pool_register.h	/^static const struct _pool_t g_pool[] = {$/;"	v	typeref:struct:_pool_t
get	commonn/configParser.cpp	/^const std::string & Section :: get(const std::string key) const$/;"	f	class:Section
get	commonn/configParser.cpp	/^const std::string& ConfigParser :: get(const std::string sectionName, const std::string keyName) const$/;"	f	class:ConfigParser
get_file	commonn/asynLog.h	/^    static FILE * get_file()$/;"	f	class:Log
get_pdata	nf_server_core.cpp	/^get_pdata()$/;"	f
get_pool_queuenum	pool_register.h	/^typedef long long (*get_pool_queuenum)(nf_server_t *);$/;"	t
get_pool_socknum	pool_register.h	/^typedef long long (*get_pool_socknum)(nf_server_t *);$/;"	t
get_queuenum	pool_register.h	/^    get_pool_queuenum get_queuenum;$/;"	m	struct:_pool_t
get_server_data	nf_server.cpp	/^    nf_server_t * NfServer :: get_server_data()$/;"	f	class:nf::NfServer
get_socknum	pool_register.h	/^    get_pool_socknum get_socknum;$/;"	m	struct:_pool_t
get_tcp_sockaddr	net.cpp	/^get_tcp_sockaddr(char * addr, int * port, $/;"	f
id	nf_server_core.h	/^    size_t id;$/;"	m	struct:_nf_server_pdata_t
idx	nf_server_core.h	/^    int idx; \/\/sapool, handle socket index$/;"	m	struct:_nf_server_pdata_t
init	commonn/asynLog.cpp	/^Log :: init(const char * name)$/;"	f	class:Log
init	commonn/memCache.cpp	/^Allocate :: init()$/;"	f	class:Allocate
init	pool_register.h	/^    init_pool init;    \/\/pool的初始化回调函数$/;"	m	struct:_pool_t
init_pool	pool_register.h	/^typedef int (*init_pool)(nf_server_t *);$/;"	t
instance	commonn/singleton.h	/^        static T * instance()$/;"	f	class:Singleton
is_empty_q	commonn/queue.cpp	/^int is_empty_q(queue_t *q)$/;"	f
is_full_q	commonn/queue.cpp	/^int is_full_q(queue_t *q)$/;"	f
items	commonn/configParser.h	/^        std::map<std::string, std::string> items;$/;"	m	class:Section
join	nf_server.cpp	/^    int NfServer :: join()$/;"	f	class:nf::NfServer
join	pool_register.h	/^    join_pool join;    \/\/pool的join函数$/;"	m	struct:_pool_t
join_pool	pool_register.h	/^typedef int (*join_pool)(nf_server_t *);$/;"	t
last_active	rapool.h	/^    time_t last_active;$/;"	m	struct:_rapool_sock_item_t
last_active	sapool.h	/^    time_t last_active;$/;"	m	struct:_sapool_sock_item_t
lf_main	lfpool.cpp	/^void * lf_main(void * param)$/;"	f
lfpool_destroy	lfpool.cpp	/^int lfpool_destroy(nf_server_t * sev)$/;"	f
lfpool_get_queuenum	lfpool.cpp	/^long long lfpool_get_queuenum(nf_server_t *)$/;"	f
lfpool_get_socknum	lfpool.cpp	/^long long lfpool_get_socknum(nf_server_t *)$/;"	f
lfpool_init	lfpool.cpp	/^int lfpool_init(nf_server_t * sev)$/;"	f
lfpool_join	lfpool.cpp	/^int lfpool_join(nf_server_t * sev)$/;"	f
lfpool_once_op	lfpool.cpp	/^static int lfpool_once_op(int epfd, int fd, int timeout)$/;"	f	file:
lfpool_pause	lfpool.cpp	/^int lfpool_pause(nf_server_t *)$/;"	f
lfpool_resume	lfpool.cpp	/^int lfpool_resume(nf_server_t *)$/;"	f
lfpool_run	lfpool.cpp	/^int lfpool_run(nf_server_t * sev)$/;"	f
lfpool_t	lfpool.cpp	/^} lfpool_t;$/;"	t	typeref:struct:_lfpool_t	file:
listen	pool_register.h	/^    listen_pool listen;  \/\/ 开始监听$/;"	m	struct:_pool_t
listen_pool	pool_register.h	/^typedef int (*listen_pool)(nf_server_t *);$/;"	t
listen_port	nf_server_core.h	/^    size_t listen_port;$/;"	m	struct:_nf_server_t
listen_prio	nf_server_core.h	/^    size_t listen_prio; \/\/sapool$/;"	m	struct:_nf_server_t
load_conf	nf_server.cpp	/^    int NfServer :: load_conf(const std::string & conf_path)$/;"	f	class:nf::NfServer
lock	commonn/singleton.h	/^        void lock()$/;"	f	class:MutexLock
lock	lfpool.cpp	/^    pthread_mutex_t lock;$/;"	m	struct:_lfpool_t	file:
log_buffer	commonn/asynLog.cpp	/^queue<string> Log :: log_buffer;$/;"	m	class:Log	file:
log_buffer	commonn/asynLog.h	/^    static queue<string> log_buffer;   $/;"	m	class:Log
log_cond	commonn/asynLog.cpp	/^pthread_cond_t Log:: log_cond;$/;"	m	class:Log	file:
log_cond	commonn/asynLog.h	/^    static pthread_cond_t  log_cond;$/;"	m	class:Log
log_mutex	commonn/asynLog.cpp	/^pthread_mutex_t Log :: log_mutex;$/;"	m	class:Log	file:
log_mutex	commonn/asynLog.h	/^    static pthread_mutex_t log_mutex;$/;"	m	class:Log
mSections	commonn/configParser.h	/^    std::map<std::string, Section> mSections;$/;"	m	class:ConfigParser
main	rapool.h	/^    pthread_t main;$/;"	m	struct:_rapool_t
main	sapool.h	/^    pthread_t main;$/;"	m	struct:_sapool_t
main	test/case/getline/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getline/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getn/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getn/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
max	test/case/getline/client_simple.cpp	15;"	d	file:
max	test/case/getline/server_simple.cpp	14;"	d	file:
max	test/case/getn/client_simple.cpp	15;"	d	file:
max	test/case/getn/server_simple.cpp	14;"	d	file:
max	test/client_simple.cpp	15;"	d	file:
max	test/server_simple.cpp	13;"	d	file:
mem_mutex	commonn/memCache.cpp	/^pthread_mutex_t Allocate :: mem_mutex[LISTS];$/;"	m	class:Allocate	file:
mem_mutex	commonn/memCache.h	/^    static pthread_mutex_t mem_mutex[LISTS];$/;"	m	class:Allocate
mutex	commonn/singleton.h	/^        pthread_mutex_t mutex;$/;"	m	class:MutexLock
name	nf_server_core.h	/^    char name[256];$/;"	m	struct:_nf_server_t
need_join	nf_server_core.h	/^    size_t need_join;$/;"	m	struct:_nf_server_t
net_accept	net.cpp	/^net_accept(int sockfd, struct sockaddr *sa, socklen_t * addrlen)$/;"	f
net_connect_to_ms	net.cpp	/^net_connect_to_ms(int sockfd, struct sockaddr *sa, $/;"	f
net_connect_to_tv	net.cpp	/^net_connect_to_tv(int fd, struct sockaddr * sa, $/;"	f
net_ep_add	net.cpp	/^net_ep_add(int epfd, int fd, int events)$/;"	f
net_ep_add_in	net.cpp	/^net_ep_add_in(int epfd, int fd)$/;"	f
net_ep_add_in1	net.cpp	/^net_ep_add_in1(int epfd, int fd)$/;"	f
net_ep_create	net.cpp	/^net_ep_create(int size)$/;"	f
net_ep_del	net.cpp	/^net_ep_del(int epfd, int fd)$/;"	f
net_tcplisten	net.cpp	/^net_tcplisten(int port, int queue)$/;"	f
next_check_time	rapool.h	/^    time_t next_check_time;$/;"	m	struct:_rapool_t
next_check_time	sapool.h	/^    time_t next_check_time;$/;"	m	struct:_sapool_t
nf	nf_server.cpp	/^namespace nf$/;"	n	file:
nf	nf_server.h	/^namespace nf$/;"	n
nf_LF_readline_worker	nf_server_app.cpp	/^nf_LF_readline_worker(void * data)$/;"	f
nf_LF_readnf_worker	nf_server_app.cpp	/^nf_LF_readnf_worker(void * data)$/;"	f
nf_RA_readline_worker	nf_server_app.cpp	/^nf_RA_readline_worker(void * data)$/;"	f
nf_SA_readline_worker	nf_server_app.cpp	/^nf_SA_readline_worker(void * data)$/;"	f
nf_callback_proc	nf_server_core.h	/^typedef int (* nf_callback_proc)(void *req);$/;"	t
nf_default_handle	nf_server_app.cpp	/^nf_default_handle()$/;"	f
nf_handle_t	nf_server_core.h	/^typedef void (* nf_handle_t)();$/;"	t
nf_pdata_init	nf_server_core.cpp	/^nf_pdata_init(nf_server_pdata_t * pdata, nf_server_t * sev)$/;"	f
nf_server_bind	nf_server_core.cpp	/^int nf_server_bind(nf_server_t * sev)$/;"	f
nf_server_create	nf_server_core.cpp	/^nf_server_create(const char * sev_name)$/;"	f
nf_server_get_qsize	nf_server_core.cpp	/^nf_server_get_qsize(nf_server_t * sev)$/;"	f
nf_server_get_read_buf	nf_server_core.cpp	/^nf_server_get_read_buf()$/;"	f
nf_server_get_readed_size	nf_server_core.cpp	/^nf_server_get_readed_size()$/;"	f
nf_server_get_readto	nf_server_core.cpp	/^nf_server_get_readto()$/;"	f
nf_server_get_socksize	nf_server_core.cpp	/^nf_server_get_socksize(nf_server_t * sev)$/;"	f
nf_server_get_thread_epfd	nf_server_core.cpp	/^nf_server_get_thread_epfd()$/;"	f
nf_server_get_thread_id	nf_server_core.cpp	/^nf_server_get_thread_id()$/;"	f
nf_server_get_write_buf	nf_server_core.cpp	/^nf_server_get_write_buf()$/;"	f
nf_server_get_writed_size	nf_server_core.cpp	/^nf_server_get_writed_size()$/;"	f
nf_server_get_writeto	nf_server_core.cpp	/^nf_server_get_writeto()$/;"	f
nf_server_init	nf_server_core.cpp	/^nf_server_init(nf_server_t * sev)$/;"	f
nf_server_listen	nf_server_core.cpp	/^int nf_server_listen(nf_server_t * sev)$/;"	f
nf_server_pdata_t	nf_server_core.h	/^typedef struct _nf_server_pdata_t nf_server_pdata_t;$/;"	t	typeref:struct:_nf_server_pdata_t
nf_server_set_writed_size	nf_server_core.cpp	/^nf_server_set_writed_size(int n)$/;"	f
nf_server_set_writed_start	nf_server_core.cpp	/^nf_server_set_writed_start(int n)$/;"	f
nf_server_t	nf_server_core.h	/^typedef struct _nf_server_t nf_server_t;$/;"	t	typeref:struct:_nf_server_t
obj	commonn/memCache.h	/^    union obj$/;"	u	class:Allocate
p_end	nf_server_core.h	/^    nf_handle_t p_end;    $/;"	m	struct:_nf_server_t
p_handle	nf_server_core.h	/^    nf_handle_t p_handle;    $/;"	m	struct:_nf_server_t
p_start	nf_server_core.h	/^    nf_handle_t p_start;     $/;"	m	struct:_nf_server_t
parser_file	commonn/configParser.cpp	/^bool ConfigParser :: parser_file(const std::string &file)$/;"	f	class:ConfigParser
pause	nf_server.cpp	/^    int NfServer :: pause()$/;"	f	class:nf::NfServer
pause	pool_register.h	/^    pause_pool pause;$/;"	m	struct:_pool_t
pause_pool	pool_register.h	/^typedef int (*pause_pool)(nf_server_t *);$/;"	t
pdata	nf_server_core.h	/^    nf_server_pdata_t * pdata;$/;"	m	struct:_nf_server_t
pid	nf_server_core.h	/^    pthread_t pid;$/;"	m	struct:_nf_server_pdata_t
pkey	nf_server_core.cpp	/^static pthread_key_t pkey;$/;"	v	file:
ponce	nf_server_core.cpp	/^static pthread_once_t ponce = PTHREAD_ONCE_INIT;$/;"	v	file:
pool	nf_server_core.h	/^    void * pool;$/;"	m	struct:_nf_server_t
pop_q	commonn/queue.cpp	/^int pop_q(queue_t *q, int *val)$/;"	f
produce_log	commonn/asynLog.cpp	/^Log :: produce_log(int event, char * s, const char * fmt, va_list args)$/;"	f	class:Log
pthread_num	nf_server_core.h	/^    size_t pthread_num;        \/\/线程池开启线程总数$/;"	m	struct:_nf_server_t
push_q	commonn/queue.cpp	/^int push_q(queue_t *q, int val)$/;"	f
qsize	nf_server_core.h	/^    size_t qsize; \/\/sapool$/;"	m	struct:_nf_server_t
queue	sapool.h	/^    queue_t queue;$/;"	m	struct:_sapool_t
queue_t	commonn/queue.h	/^typedef struct _queue_t queue_t;$/;"	t	typeref:struct:_queue_t
rapool_add	rapool.cpp	/^rapool_add(nf_server_t * sev, int sock, struct sockaddr_in *addr)$/;"	f
rapool_close_pool_sockets	rapool.cpp	/^rapool_close_pool_sockets(nf_server_t *sev, bool is_listenfd)$/;"	f	file:
rapool_del	rapool.cpp	/^rapool_del(nf_server_t *sev, int idx, int alive, bool remove)$/;"	f
rapool_destroy	rapool.cpp	/^int rapool_destroy(nf_server_t *sev)$/;"	f
rapool_epoll_add_read	rapool.cpp	/^rapool_epoll_add_read(nf_server_t *sev, int idx, int work_reactor)$/;"	f
rapool_epoll_del	rapool.cpp	/^rapool_epoll_del(nf_server_t * sev, int idx, int work_reactor)$/;"	f
rapool_get_queuenum	rapool.cpp	/^rapool_get_queuenum(nf_server_t *sev)$/;"	f
rapool_init	rapool.cpp	/^rapool_init(nf_server_t *sev)$/;"	f
rapool_join	rapool.cpp	/^rapool_join(nf_server_t *sev)$/;"	f
rapool_listen	rapool.cpp	/^rapool_listen(nf_server_t *sev)$/;"	f
rapool_main	rapool.cpp	/^rapool_main(void *param)$/;"	f
rapool_pause	rapool.cpp	/^rapool_pause(nf_server_t *sev)$/;"	f
rapool_produce	rapool.cpp	/^rapool_produce(nf_server_t * sev, struct sockaddr * addr, $/;"	f
rapool_pthread_cond_timewait	rapool.cpp	/^rapool_pthread_cond_timewait(rapool_t *pool)$/;"	f
rapool_reactor	rapool.cpp	/^rapool_reactor(rapool_t * pool, nf_server_pdata_t * pdata)$/;"	f
rapool_resume	rapool.cpp	/^int rapool_resume(nf_server_t *sev)$/;"	f
rapool_run	rapool.cpp	/^rapool_run(nf_server_t *sev)$/;"	f
rapool_sock_item_t	rapool.h	/^typedef struct _rapool_sock_item_t rapool_sock_item_t;$/;"	t	typeref:struct:_rapool_sock_item_t
rapool_t	rapool.h	/^typedef struct _rapool_t rapool_t;$/;"	t	typeref:struct:_rapool_t
rapool_workers	rapool.cpp	/^rapool_workers(void * param)$/;"	f
read_buf	nf_server_core.h	/^    void *read_buf;$/;"	m	struct:_nf_server_pdata_t
read_size	nf_server_core.h	/^    size_t read_size;$/;"	m	struct:_nf_server_pdata_t
read_start	nf_server_core.h	/^    int read_start;$/;"	m	struct:_nf_server_pdata_t
read_to	nf_server_core.h	/^    size_t read_to;$/;"	m	struct:_nf_server_t
readed_size	nf_server_core.h	/^    size_t readed_size;$/;"	m	struct:_nf_server_pdata_t
readn	net.cpp	/^readn(int fd, void *usrbuf, size_t n)$/;"	f
readn_to_ms	net.cpp	/^readn_to_ms(int fd, void *ptr, size_t nbytes, int msecs)$/;"	f
ready_cond	rapool.h	/^    pthread_cond_t  ready_cond;$/;"	m	struct:_rapool_t
ready_cond	sapool.h	/^    pthread_cond_t  ready_cond;$/;"	m	struct:_sapool_t
ready_mutex	rapool.h	/^    pthread_mutex_t ready_mutex;$/;"	m	struct:_rapool_t
ready_mutex	sapool.h	/^    pthread_mutex_t ready_mutex;$/;"	m	struct:_sapool_t
rear	commonn/queue.h	/^    int rear;$/;"	m	struct:_queue_t
refill	commonn/memCache.cpp	/^Allocate :: refill(size_t n)$/;"	f	class:Allocate
resume	nf_server.cpp	/^    int NfServer :: resume()$/;"	f	class:nf::NfServer
resume	pool_register.h	/^    resume_pool resume;$/;"	m	struct:_pool_t
resume_pool	pool_register.h	/^typedef int (*resume_pool)(nf_server_t *);$/;"	t
rio	nf_server_core.h	/^    rio_t rio;$/;"	m	struct:_nf_server_pdata_t
rio_bufptr	net.h	/^    char * rio_bufptr;$/;"	m	struct:_rio_t
rio_cnt	net.h	/^    int rio_cnt;$/;"	m	struct:_rio_t
rio_fd	net.h	/^    int rio_fd;$/;"	m	struct:_rio_t
rio_init	net.cpp	/^void rio_init(rio_t *rp, int fd, int len)$/;"	f
rio_len	net.h	/^    size_t rio_len;$/;"	m	struct:_rio_t
rio_ptr	net.h	/^    char * rio_ptr;$/;"	m	struct:_rio_t
rio_read	net.cpp	/^rio_read(rio_t *rp, char *usrbuf, size_t n)$/;"	f	file:
rio_readline	net.cpp	/^rio_readline(rio_t *rp, void *usrbuf, size_t maxlen, int * st)$/;"	f
rio_readline_to_ms	net.cpp	/^rio_readline_to_ms(rio_t *rp, void *usrbuf, size_t maxlen, int msecs)$/;"	f
rio_readn	net.cpp	/^rio_readn(rio_t *rp, void *usrbuf, size_t n, int * st)$/;"	f
rio_readn_to_ms	net.cpp	/^rio_readn_to_ms(rio_t *rp, void *usrbuf, size_t n, int msecs)$/;"	f
rio_t	net.h	/^} rio_t;$/;"	t	typeref:struct:_rio_t
rp	rapool.h	/^    rio_t rp;$/;"	m	struct:_rapool_sock_item_t
rp	sapool.h	/^    rio_t rp;$/;"	m	struct:_sapool_sock_item_t
run	nf_server.cpp	/^    int NfServer :: run()$/;"	f	class:nf::NfServer
run	nf_server_core.h	/^    int run;     $/;"	m	struct:_nf_server_t
run	pool_register.h	/^    run_pool run;    \/\/pool的运行回调函数$/;"	m	struct:_pool_t
run	rapool.h	/^    int * run;$/;"	m	struct:_rapool_t
run	sapool.h	/^    int * run;$/;"	m	struct:_sapool_t
run_pool	pool_register.h	/^typedef int (*run_pool)(nf_server_t *);$/;"	t
run_thread_num	nf_server_core.h	/^    int run_thread_num;        \/\/工作线程数$/;"	m	struct:_nf_server_t
sapool_add	sapool.cpp	/^sapool_add(nf_server_t * sev, int sock, struct sockaddr_in *addr)$/;"	f
sapool_check_timeout	sapool.cpp	/^sapool_check_timeout(nf_server_t *sev)$/;"	f
sapool_close_pool_sockets	sapool.cpp	/^sapool_close_pool_sockets(nf_server_t *sev, bool is_listenfd)$/;"	f	file:
sapool_consume	sapool.cpp	/^sapool_consume(sapool_t * pool, nf_server_pdata_t * pdata)$/;"	f
sapool_del	sapool.cpp	/^sapool_del(nf_server_t *sev, int idx, int alive, bool remove)$/;"	f
sapool_destroy	sapool.cpp	/^int sapool_destroy(nf_server_t *sev)$/;"	f
sapool_epoll_add	sapool.cpp	/^sapool_epoll_add(nf_server_t *sev, int idx)$/;"	f
sapool_epoll_del	sapool.cpp	/^sapool_epoll_del(nf_server_t *sev, int idx)$/;"	f
sapool_get	sapool.cpp	/^sapool_get(nf_server_t *sev, int *idx)$/;"	f
sapool_get_queuenum	sapool.cpp	/^sapool_get_queuenum(nf_server_t *sev)$/;"	f
sapool_init	sapool.cpp	/^sapool_init(nf_server_t *sev)$/;"	f
sapool_join	sapool.cpp	/^sapool_join(nf_server_t *sev)$/;"	f
sapool_listen	sapool.cpp	/^sapool_listen(nf_server_t *sev)$/;"	f
sapool_main	sapool.cpp	/^sapool_main(void *param)$/;"	f
sapool_pause	sapool.cpp	/^sapool_pause(nf_server_t *sev)$/;"	f
sapool_produce	sapool.cpp	/^sapool_produce(nf_server_t * sev, struct sockaddr * addr, $/;"	f
sapool_pthread_cond_timewait	sapool.cpp	/^sapool_pthread_cond_timewait(sapool_t *pool)$/;"	f
sapool_put	sapool.cpp	/^sapool_put(sapool_t *pool, int idx)$/;"	f
sapool_resume	sapool.cpp	/^int sapool_resume(nf_server_t *sev)$/;"	f
sapool_run	sapool.cpp	/^sapool_run(nf_server_t *sev)$/;"	f
sapool_sock_item_t	nf_server_core.h	/^typedef _sapool_sock_item_t sapool_sock_item_t;$/;"	t
sapool_sock_item_t	sapool.h	/^typedef struct _sapool_sock_item_t sapool_sock_item_t;$/;"	t	typeref:struct:_sapool_sock_item_t
sapool_t	nf_server_core.h	/^typedef _sapool_t sapool_t;$/;"	t
sapool_t	sapool.h	/^typedef struct _sapool_t sapool_t;$/;"	t	typeref:struct:_sapool_t
sapool_workers	sapool.cpp	/^sapool_workers(void * param)$/;"	f
scan	commonn/configParser.cpp	/^void ConfigParser :: scan() const$/;"	f	class:ConfigParser
scan	commonn/configParser.cpp	/^void Section :: scan() const$/;"	f	class:Section
sendn	net.cpp	/^sendn(int fd, void *usrbuf, size_t n)$/;"	f
sendn_to_ms	net.cpp	/^sendn_to_ms(int fd, const void *ptr, size_t nbytes, int msecs)$/;"	f
server	nf_server_core.h	/^    nf_server_t *server;$/;"	m	struct:_nf_server_pdata_t
server_type	nf_server_core.h	/^    size_t server_type;$/;"	m	struct:_nf_server_t
set	commonn/configParser.h	/^        inline void set(const std::string &key, const std::string &val)$/;"	f	class:Section
set	commonn/configParser.h	/^    inline void set(const std::string &sectionName, const std::string &keyName, $/;"	f	class:ConfigParser
set_clc_fd	net.cpp	/^set_clc_fd(int fd, int flags)$/;"	f
set_fd	net.cpp	/^set_fd(int fd, int flags)$/;"	f
set_fd_block	net.cpp	/^set_fd_block(int fd)$/;"	f
set_fd_noblock	net.cpp	/^set_fd_noblock(int fd)$/;"	f
set_file	commonn/asynLog.h	/^    static void set_file(FILE * file)$/;"	f	class:Log
set_linger	net.cpp	/^set_linger(int fd, int val)$/;"	f
set_pthread_data	nf_server_core.cpp	/^set_pthread_data(nf_server_pdata_t *data)$/;"	f
set_server_name	nf_server.cpp	/^    int NfServer :: set_server_name(const char * sev_name)$/;"	f	class:nf::NfServer
set_server_startfun	nf_server.cpp	/^    int NfServer :: set_server_startfun( nf_handle_t start )$/;"	f	class:nf::NfServer
set_sev_socketopt	nf_server_core.cpp	/^int set_sev_socketopt(nf_server_t *sev, int fd)$/;"	f
set_tcp_sockaddr	net.cpp	/^set_tcp_sockaddr(char * addr, int port, $/;"	f
set_thread_endfun	nf_server.cpp	/^    int NfServer :: set_thread_endfun( nf_handle_t end )$/;"	f	class:nf::NfServer
set_thread_startfun	nf_server.cpp	/^    int NfServer :: set_thread_startfun( nf_handle_t start ) $/;"	f	class:nf::NfServer
set_work_callback	nf_server.cpp	/^    int NfServer :: set_work_callback(nf_callback_proc run)$/;"	f	class:nf::NfServer
sev_data	nf_server.h	/^        nf_server_t *sev_data;$/;"	m	class:nf::NfServer
sev_sock_id	rapool.h	/^    int sev_sock_id;$/;"	m	struct:_rapool_t
sev_sock_id	sapool.h	/^    int sev_sock_id;$/;"	m	struct:_sapool_t
sev_socket	nf_server_core.h	/^    int sev_socket; $/;"	m	struct:_nf_server_t
size	commonn/queue.h	/^    int size;$/;"	m	struct:_queue_t
size	rapool.h	/^    int size;$/;"	m	struct:_rapool_t
size	sapool.h	/^    int size;$/;"	m	struct:_sapool_t
sock	rapool.h	/^    int sock;$/;"	m	struct:_rapool_sock_item_t
sock	sapool.h	/^    int sock;$/;"	m	struct:_sapool_sock_item_t
sock_family	nf_server_core.h	/^    int sock_family;$/;"	m	struct:_nf_server_t
sockets	rapool.h	/^    rapool_sock_item_t * sockets;$/;"	m	struct:_rapool_t
sockets	sapool.h	/^    sapool_sock_item_t * sockets;$/;"	m	struct:_sapool_t
socksize	nf_server_core.h	/^    size_t socksize;  \/\/sapool$/;"	m	struct:_nf_server_t
stack_size	nf_server_core.h	/^    size_t stack_size; \/\/线程栈大小$/;"	m	struct:_nf_server_t
status	nf_server_core.h	/^    SERVER_STATUS_T status;$/;"	m	struct:_nf_server_t
status	rapool.h	/^    int status;$/;"	m	struct:_rapool_sock_item_t
status	sapool.h	/^    int status;$/;"	m	struct:_sapool_sock_item_t
stop	commonn/asynLog.h	/^    static void stop()$/;"	f	class:Log
stop	nf_server.cpp	/^    int NfServer :: stop()$/;"	f	class:nf::NfServer
str_prefix	commonn/asynLog.cpp	/^string Log :: str_prefix[4] = {"[DEBUG]  ", $/;"	m	class:Log	file:
str_prefix	commonn/asynLog.h	/^    static string str_prefix[4];$/;"	m	class:Log
thread_read_buf	nf_server_core.h	/^    size_t thread_read_buf;$/;"	m	struct:_nf_server_t
thread_usr_buf	nf_server_core.h	/^    size_t thread_usr_buf;$/;"	m	struct:_nf_server_t
thread_write_buf	nf_server_core.h	/^    size_t thread_write_buf;$/;"	m	struct:_nf_server_t
timeout	nf_server_core.h	/^    size_t timeout; \/\/sapool$/;"	m	struct:_nf_server_t
timeout	rapool.h	/^    int timeout;        \/\/epoll的超时时间$/;"	m	struct:_rapool_t
timeout	sapool.h	/^    int timeout;        \/\/epoll的超时时间$/;"	m	struct:_sapool_t
unlock	commonn/singleton.h	/^        void unlock()$/;"	f	class:MutexLock
using_size	rapool.h	/^    long long using_size;$/;"	m	struct:_rapool_t
using_size	sapool.h	/^    long long using_size;$/;"	m	struct:_sapool_t
usr_buf	nf_server_core.h	/^    void *usr_buf;$/;"	m	struct:_nf_server_pdata_t
usr_size	nf_server_core.h	/^    size_t usr_size;$/;"	m	struct:_nf_server_pdata_t
work	test/case/getline/client_simple.cpp	/^void * work(void * arg)$/;"	f
work	test/case/getn/client_simple.cpp	/^void * work(void * arg)$/;"	f
work	test/client_simple.cpp	/^void * work(void * arg)$/;"	f
work_prio	nf_server_core.h	/^    size_t work_prio;   \/\/sapool$/;"	m	struct:_nf_server_t
write_buf	nf_server_core.h	/^    void *write_buf;$/;"	m	struct:_nf_server_pdata_t
write_log	commonn/asynLog.cpp	/^Log :: write_log(void *)$/;"	f	class:Log
write_size	nf_server_core.h	/^    size_t write_size;$/;"	m	struct:_nf_server_pdata_t
write_start	nf_server_core.h	/^    int write_start;$/;"	m	struct:_nf_server_pdata_t
write_to	nf_server_core.h	/^    size_t write_to;$/;"	m	struct:_nf_server_t
writed_size	nf_server_core.h	/^    size_t writed_size;$/;"	m	struct:_nf_server_pdata_t
~ConfigParser	commonn/configParser.h	/^        virtual ~ConfigParser(){}$/;"	f	class:ConfigParser
~MutexLock	commonn/singleton.h	/^        ~MutexLock()$/;"	f	class:MutexLock
~NfServer	nf_server.cpp	/^    NfServer :: ~NfServer()$/;"	f	class:nf::NfServer
