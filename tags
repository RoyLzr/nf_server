!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACCEPT	NfUnit/baseEvent.h	/^        ACCEPT,$/;"	e	enum:SockEventBase::__anon14
AFLAGS	Makefile	/^AFLAGS := -cvr$/;"	m
ALIGN	commonn/memCache.h	/^enum {ALIGN = 256};$/;"	e	enum:__anon3
AR	Makefile	/^AR := ar$/;"	m
AddTask	commonn/ThreadPool.cpp	/^int CThreadPool::AddTask(CTask* pTask)$/;"	f	class:CThreadPool
Allocate	commonn/memCache.h	/^class Allocate$/;"	c
AutoLock	commonn/lock.h	/^        inline AutoLock(Lock &l) : _lock(l) $/;"	f	class:AutoLock
AutoLock	commonn/lock.h	/^class AutoLock$/;"	c
AutoMLock	NfUnit/eventqueue.h	/^        typedef AutoLock<MLock> AutoMLock;$/;"	t	class:BlockEQueue
AutoMLock	NfUnit/eventqueue.h	/^        typedef AutoLock<MLock> AutoMLock;$/;"	t	class:ELQueue
AutoMLock	NfUnit/syncReactor.h	/^        typedef AutoLock<MLock> AutoMLock;$/;"	t	class:SyncReactor
BASE	NfUnit/baseEvent.h	/^        BASE,$/;"	e	enum:SockEventBase::__anon14
BUFLEN	test/case/getline/server_simple.cpp	15;"	d	file:
BUFLEN	test/case/getn/server_simple.cpp	15;"	d	file:
BUFLEN	test/server_simple.cpp	15;"	d	file:
BUSY	rapool.cpp	/^    BUSY$/;"	e	enum:__anon16	file:
BUSY	sapool.cpp	/^    BUSY$/;"	e	enum:__anon18	file:
BlockEQueue	NfUnit/eventqueue.cpp	/^BlockEQueue::BlockEQueue() :_cond(_lock) {}$/;"	f	class:BlockEQueue
BlockEQueue	NfUnit/eventqueue.h	/^class BlockEQueue : public IEQueue$/;"	c
Buffer	Buffer.cpp	/^Buffer :: Buffer(const Buffer & rhs)$/;"	f	class:Buffer
Buffer	Buffer.h	/^        explicit Buffer() : cache(NULL),$/;"	f	class:Buffer
Buffer	Buffer.h	/^        explicit Buffer(int size)$/;"	f	class:Buffer
Buffer	Buffer.h	/^class Buffer$/;"	c
CANCELED	interface/ievent.h	/^            CANCELED,$/;"	e	enum:IEvent::__anon8
CFLAGS	Makefile	/^CFLAGS := -g -c -Wall$/;"	m
CHUNK_NODE	commonn/memCache.h	/^enum {CHUNK_NODE = 20};$/;"	e	enum:__anon6
CLOSESOCK	interface/ievent.h	/^            CLOSESOCK   =      0x10,$/;"	e	enum:IEvent::__anon9
COMMON_DIR	Makefile	/^COMMON_DIR := .\/commonn$/;"	m
COM_OBJS	Makefile	/^COM_OBJS := timer.o queue.o memCache.o asynLog.o$/;"	m
CPU	interface/ievent.h	/^            CPU,$/;"	e	enum:IEvent::__anon10
CTask	commonn/ThreadPool.h	/^        CTask()$/;"	f	class:CTask
CTask	commonn/ThreadPool.h	/^class CTask $/;"	c
CThreadNotify	commonn/ThreadPool.cpp	/^CThreadNotify :: CThreadNotify()$/;"	f	class:CThreadNotify
CThreadNotify	commonn/ThreadPool.h	/^class CThreadNotify$/;"	c
CThreadPool	commonn/ThreadPool.cpp	/^CThreadPool::CThreadPool()$/;"	f	class:CThreadPool
CThreadPool	commonn/ThreadPool.h	/^class CThreadPool $/;"	c
CWorkerThread	commonn/ThreadPool.cpp	/^CWorkerThread::CWorkerThread()$/;"	f	class:CWorkerThread
CWorkerThread	commonn/ThreadPool.h	/^class CWorkerThread $/;"	c
CXX	Makefile	/^CXX := g++$/;"	m
ConfigParser	commonn/configParser.h	/^        ConfigParser(){}$/;"	f	class:ConfigParser
ConfigParser	commonn/configParser.h	/^class ConfigParser$/;"	c
DEBUG	commonn/asynLog.cpp	/^Log :: DEBUG(const char * fmt, ...)$/;"	f	class:Log
DEFAULT_CHECK_INTERVAL	sapool.cpp	/^    DEFAULT_CHECK_INTERVAL = 10,  \/\/\/默认check_interval, 10ms$/;"	e	enum:__anon17	file:
DEFAULT_QUEUE_LEN	sapool.cpp	/^    DEFAULT_QUEUE_LEN = 100,      \/\/\/默认的等待队列的长度 100$/;"	e	enum:__anon17	file:
DEFAULT_SOCK_NUM	sapool.cpp	/^    DEFAULT_SOCK_NUM = 500,       \/\/\/同时维护的最大sock句柄数，500$/;"	e	enum:__anon17	file:
DEFAULT_TIMEOUT	sapool.cpp	/^    DEFAULT_TIMEOUT = 60000,         \/\/\/等待队列里面的默认超时时间t, 60s$/;"	e	enum:__anon17	file:
DELETED	Buffer.h	/^static const bool DELETED = true;$/;"	v
DONE	interface/ievent.h	/^            DONE,$/;"	e	enum:IEvent::__anon8
Destory	commonn/ThreadPool.cpp	/^void CThreadPool::Destory()$/;"	f	class:CThreadPool
ELQueue	NfUnit/eventqueue.h	/^        ELQueue() {}$/;"	f	class:ELQueue
ELQueue	NfUnit/eventqueue.h	/^class ELQueue : public IEQueue $/;"	c
EPOLL_ACTIVED	util.h	31;"	d
EPOLL_UNACTIVED	util.h	32;"	d
EQueue	NfUnit/eventqueue.h	/^        EQueue() : begin(0), $/;"	f	class:EQueue
EQueue	NfUnit/eventqueue.h	/^class EQueue : public IEQueue$/;"	c
ERROR	commonn/asynLog.cpp	/^Log :: ERROR(const char * fmt, ...)$/;"	f	class:Log
ERROR	interface/ievent.h	/^            ERROR       =      0x20,$/;"	e	enum:IEvent::__anon9
EV_ACTIVE	util.h	17;"	d
EV_EPOLL_ACTIVE	util.h	20;"	d
EV_INIT	util.h	15;"	d
EV_INSERTED	util.h	16;"	d
EV_LISTEN	util.h	11;"	d
EV_READ	util.h	9;"	d
EV_READUNFIN	util.h	18;"	d
EV_TIMEOUT	util.h	8;"	d
EV_WRITE	util.h	10;"	d
EV_WRITEUNFIN	util.h	19;"	d
EXECUTE	Makefile	/^EXECUTE := $(TAR_OBJ)$/;"	m
EXTReactor	NfUnit/extreactor.cpp	/^EXTReactor::EXTReactor() : _queue(0), $/;"	f	class:EXTReactor
EXTReactor	NfUnit/extreactor.h	/^class EXTReactor : public IReactor$/;"	c
Event	event.h	/^    explicit Event() : ev_fd(0),$/;"	f	class:Event
Event	event.h	/^class Event : private Uncopyable$/;"	c
EventBase	NfUnit/baseEvent.cpp	/^EventBase::EventBase() : _fd(-1), $/;"	f	class:EventBase
EventBase	NfUnit/baseEvent.h	/^class EventBase : public IEvent$/;"	c
EventCallback	NfUnit/baseEvent.cpp	/^void SockEventBase::EventCallback()$/;"	f	class:SockEventBase
EventCallback	NfUnit/baseEvent.h	/^        virtual void EventCallback() { _cb(this, _cbp); }$/;"	f	class:EventBase
EventCallback	testUnit/testEXTReactor/main.cpp	/^          void EventCallback() $/;"	f	class:TestEvent
EventCallback	testUnit/testQueue/main.cpp	/^          void EventCallback() {return;}$/;"	f	class:TestEvent
EventCallback	testUnit/testSyncReactor/main.cpp	/^          void EventCallback()$/;"	f	class:TestEvent
EventTask	event.h	/^        EventTask() : ev_task(NULL)$/;"	f	class:EventTask
EventTask	event.h	/^        EventTask(Event * ev) : ev_task(ev)$/;"	f	class:EventTask
EventTask	event.h	/^class EventTask : public CTask$/;"	c
Execute	commonn/ThreadPool.cpp	/^void CWorkerThread::Execute()$/;"	f	class:CWorkerThread
FD_ACTIVE	util.h	29;"	d
FD_NOSLEEP	util.h	28;"	d
FREELIST_INDEX	commonn/memCache.h	/^    static size_t FREELIST_INDEX(size_t n)$/;"	f	class:Allocate
FRESHLIMIT	Buffer.h	/^static const bool FRESHLIMIT = 4096;$/;"	v
FRESHLIMIT	Buffer.h	/^static const bool FRESHLIMIT = 8;$/;"	v
Factory	factory.h	/^        Factory(const std::string  & conf)$/;"	f	class:Factory
Factory	factory.h	/^class Factory$/;"	c
GetThreadIdx	commonn/ThreadPool.h	/^        int GetThreadIdx() $/;"	f	class:CWorkerThread
GetWorkerBuff	commonn/ThreadPool.h	/^        void * GetWorkerBuff()$/;"	f	class:CWorkerThread
GetWorkerLen	commonn/ThreadPool.h	/^        int GetWorkerLen()$/;"	f	class:CWorkerThread
IDLE	rapool.cpp	/^    IDLE = 0,$/;"	e	enum:__anon16	file:
IDLE	sapool.cpp	/^    IDLE = 0,$/;"	e	enum:__anon18	file:
IEQueue	interface/iequeue.h	/^class IEQueue : public Uncopyable$/;"	c
IEvent	interface/ievent.h	/^        IEvent() {}$/;"	f	class:IEvent
IEvent	interface/ievent.h	/^class IEvent : public IRef$/;"	c
INIT	interface/ievent.h	/^            INIT,$/;"	e	enum:IEvent::__anon8
INIT	interface/ireactor.h	/^            INIT,$/;"	e	enum:IReactor::__anon7
INIT	nf_server_core.h	/^    INIT    = 0,$/;"	e	enum:__anon11
IOREADABLE	interface/ievent.h	/^            IOREADABLE  =      0x02,$/;"	e	enum:IEvent::__anon9
IOWRITEABLE	interface/ievent.h	/^            IOWRITEABLE =      0x04,$/;"	e	enum:IEvent::__anon9
IReactor	interface/ireactor.h	/^        IReactor() {};$/;"	f	class:IReactor
IReactor	interface/ireactor.h	/^class IReactor $/;"	c
IRef	interface/iref.h	/^        IRef(): cnt(1)$/;"	f	class:IRef
IRef	interface/iref.h	/^class IRef$/;"	c
LEVEL	commonn/asynLog.cpp	/^int Log :: LEVEL = LOG_DEBUG;$/;"	m	class:Log	file:
LEVEL	commonn/asynLog.h	/^    static int LEVEL;$/;"	m	class:Log
LINE_READ_CALLBACK_T	NfUnit/lineEvent.h	/^        typedef void (* LINE_READ_CALLBACK_T)(LineEvent *);$/;"	t	class:LineEvent
LINE_WRITE_CALLBACK_T	NfUnit/lineEvent.h	/^        typedef void (* LINE_WRITE_CALLBACK_T)(LineEvent *);$/;"	t	class:LineEvent
LISTENER_PRIORITY	rapool.h	20;"	d
LISTENER_PRIORITY	sapool.h	26;"	d
LISTS	commonn/memCache.h	/^enum {LISTS = MAX_BYTES\/ALIGN};$/;"	e	enum:__anon5
LOG_DEBUG	commonn/asynLog.h	/^    LOG_DEBUG,$/;"	e	enum:__anon1
LOG_ERROR	commonn/asynLog.h	/^    LOG_ERROR,$/;"	e	enum:__anon1
LOG_INIT	commonn/asynLog.h	/^    LOG_INIT,$/;"	e	enum:__anon2
LOG_MAXLINE	commonn/asynLog.h	/^    LOG_MAXLINE = 1024$/;"	e	enum:__anon1
LOG_NOTICE	commonn/asynLog.h	/^    LOG_NOTICE,$/;"	e	enum:__anon1
LOG_RUN	commonn/asynLog.h	/^    LOG_RUN,$/;"	e	enum:__anon2
LOG_STOP	commonn/asynLog.h	/^    LOG_STOP$/;"	e	enum:__anon2
LOG_WARN	commonn/asynLog.h	/^    LOG_WARN, $/;"	e	enum:__anon1
LfServer	lfpool.h	/^        LfServer(){};$/;"	f	class:LfServer
LfServer	lfpool.h	/^class LfServer : public NfServer$/;"	c
LineEvent	NfUnit/lineEvent.h	/^        LineEvent() : _read_done_callback(0),$/;"	f	class:LineEvent
LineEvent	NfUnit/lineEvent.h	/^class LineEvent : public SockEventBase $/;"	c
ListenEvent	event.h	/^        explicit ListenEvent() : Event(),$/;"	f	class:ListenEvent
ListenEvent	event.h	/^class ListenEvent : public Event$/;"	c
Lock	commonn/ThreadPool.h	/^	void Lock() $/;"	f	class:CThreadNotify
Lock	commonn/singleton.h	/^        static MutexLock Lock;$/;"	m	class:Singleton
Lock	commonn/singleton.h	/^MutexLock Singleton<T>::Lock;$/;"	m	class:Singleton
Log	commonn/asynLog.h	/^class Log$/;"	c
MAX	rapool.cpp	16;"	d	file:
MAX	sapool.cpp	18;"	d	file:
MAX_BYTES	commonn/memCache.h	/^enum {MAX_BYTES = 4096};$/;"	e	enum:__anon4
MCondition	commonn/lock.h	/^        MCondition(MLock &l) : _lock(l._lock), _waits(0) $/;"	f	class:MCondition
MCondition	commonn/lock.h	/^        MCondition(pthread_mutex_t &l) : _lock(l), _waits(0) $/;"	f	class:MCondition
MCondition	commonn/lock.h	/^class MCondition$/;"	c
MLock	commonn/lock.h	/^        inline MLock() $/;"	f	class:MLock
MLock	commonn/lock.h	/^class MLock$/;"	c
MutexLock	commonn/singleton.h	/^        MutexLock()$/;"	f	class:MutexLock
MutexLock	commonn/singleton.h	/^class MutexLock$/;"	c
NET	interface/ievent.h	/^            NET,$/;"	e	enum:IEvent::__anon10
NFSVR_LONG_CONNEC	nf_server_core.h	/^    NFSVR_LONG_CONNEC$/;"	e	enum:__anon13
NFSVR_POOL_NUM	nf_server_core.h	/^    NFSVR_POOL_NUM,     \/\/当前有多少个pool    $/;"	e	enum:__anon12
NFSVR_RAPOOL	nf_server_core.h	/^    NFSVR_RAPOOL,        \/\/reactor + pthread IO密集，thread 数与核有关$/;"	e	enum:__anon12
NFSVR_SAPOOL	nf_server_core.h	/^    NFSVR_SAPOOL,        \/\/建议用于多线程长连接     $/;"	e	enum:__anon12
NFSVR_SHORT_CONNEC	nf_server_core.h	/^    NFSVR_SHORT_CONNEC = 0,$/;"	e	enum:__anon13
NOTICE	commonn/asynLog.cpp	/^Log :: NOTICE(const char * fmt, ...)$/;"	f	class:Log
NfReactor	nf_server_core.h	/^        NfReactor() : Reactor()$/;"	f	class:NfReactor
NfReactor	nf_server_core.h	/^class NfReactor : public Reactor$/;"	c
NfServer	nf_server.cpp	/^NfServer :: NfServer()$/;"	f	class:NfServer
NfServer	nf_server.h	/^class NfServer : private Uncopyable$/;"	c
NonBlockFun	nf_base_work.h	/^        NonBlockFun(){};$/;"	f	class:NonBlockFun
NonBlockFun	nf_base_work.h	/^class NonBlockFun : public ParseFun$/;"	c
NonBlockReadLine	nf_base_work.h	/^        NonBlockReadLine(){}$/;"	f	class:NonBlockReadLine
NonBlockReadLine	nf_base_work.h	/^class NonBlockReadLine : public NonBlockFun$/;"	c
NonBlockWrite	nf_base_work.h	/^        NonBlockWrite(){}$/;"	f	class:NonBlockWrite
NonBlockWrite	nf_base_work.h	/^class NonBlockWrite : public NonBlockFun$/;"	c
OBJS	Makefile	/^OBJS := net.o nf_server.o rapool.o timer.o nf_server_core.o \\$/;"	m
PAUSE	interface/ireactor.h	/^            PAUSE,$/;"	e	enum:IReactor::__anon7
PAUSE	nf_server_core.h	/^    PAUSE   = 2,$/;"	e	enum:__anon11
ParseFun	nf_base_work.h	/^        ParseFun(){};$/;"	f	class:ParseFun
ParseFun	nf_base_work.h	/^class ParseFun$/;"	c
PushTask	commonn/ThreadPool.cpp	/^void CWorkerThread::PushTask(CTask* pTask)$/;"	f	class:CWorkerThread
RA_CHECK_INTERVAL	rapool.cpp	/^    RA_CHECK_INTERVAL = 10,  \/\/\/默认check_interval, 10ms$/;"	e	enum:__anon15	file:
RA_INIT	util.h	24;"	d
RA_ONCE	util.h	25;"	d
RA_SOCK_NUM	rapool.cpp	/^    RA_SOCK_NUM = 500,       \/\/\/同时维护的最大sock句柄数，500$/;"	e	enum:__anon15	file:
RA_THREAD	util.h	23;"	d
RA_TIMEOUT	rapool.cpp	/^    RA_TIMEOUT = 60,         \/\/\/等待队列里面的默认超时时间t, 60s$/;"	e	enum:__anon15	file:
READ	NfUnit/baseEvent.h	/^        READ,$/;"	e	enum:SockEventBase::__anon14
READY	interface/ievent.h	/^            READY,$/;"	e	enum:IEvent::__anon8
READY	sapool.cpp	/^    READY,$/;"	e	enum:__anon18	file:
ROUND_UP	commonn/memCache.h	/^    static size_t ROUND_UP(size_t n)$/;"	f	class:Allocate
RUNNING	interface/ievent.h	/^            RUNNING,$/;"	e	enum:IEvent::__anon8
RUNNING	interface/ireactor.h	/^            RUNNING,$/;"	e	enum:IReactor::__anon7
RUNNING	nf_server_core.h	/^    RUNNING = 1,$/;"	e	enum:__anon11
RaServer	rapool.h	/^        RaServer(){};$/;"	f	class:RaServer
RaServer	rapool.h	/^class RaServer : public NfServer$/;"	c
Reactor	reactor.h	/^        Reactor() : event_count(0),$/;"	f	class:Reactor
Reactor	reactor.h	/^class Reactor : private Uncopyable$/;"	c
ReadEvent	event.h	/^        explicit ReadEvent() : Event(),$/;"	f	class:ReadEvent
ReadEvent	event.h	/^        explicit ReadEvent(int len) : Event(),$/;"	f	class:ReadEvent
ReadEvent	event.h	/^class ReadEvent : public Event$/;"	c
SERVER_STATUS_T	nf_server_core.h	/^}SERVER_STATUS_T;$/;"	t	typeref:enum:__anon11
SIGNAL	interface/ievent.h	/^            SIGNAL      =      0x08,$/;"	e	enum:IEvent::__anon9
STATUS	commonn/asynLog.cpp	/^int Log :: STATUS = LOG_INIT;$/;"	m	class:Log	file:
STATUS	commonn/asynLog.h	/^    static int STATUS;   $/;"	m	class:Log
STOP	interface/ireactor.h	/^            STOP,$/;"	e	enum:IReactor::__anon7
STOP	nf_server_core.h	/^    STOP    = 3$/;"	e	enum:__anon11
SVR_OBJS	Makefile	/^SVR_OBJS := net.o nf_server.o rapool.o nf_server_core.o \\$/;"	m
SaServer	sapool.h	/^        SaServer() : NfServer()$/;"	f	class:SaServer
SaServer	sapool.h	/^class SaServer : public NfServer$/;"	c
Section	commonn/configParser.h	/^class Section$/;"	c
Server	commonn/Server.h	/^        Server(){};$/;"	f	class:Server
Server	commonn/Server.h	/^class Server$/;"	c
SetBuff	commonn/ThreadPool.h	/^        void SetBuff(int size)$/;"	f	class:CWorkerThread
SetThreadIdx	commonn/ThreadPool.h	/^	    void SetThreadIdx(int idx) $/;"	f	class:CWorkerThread
Signal	commonn/ThreadPool.h	/^	void Signal() $/;"	f	class:CThreadNotify
Singleton	commonn/singleton.h	/^class Singleton$/;"	c
SmartPtr	interface/iref.h	/^        SmartPtr() : event(0)$/;"	f	class:SmartPtr
SmartPtr	interface/iref.h	/^        SmartPtr(const SmartPtr & rhs)$/;"	f	class:SmartPtr
SmartPtr	interface/iref.h	/^        explicit SmartPtr(T * t) : event(t) $/;"	f	class:SmartPtr
SmartPtr	interface/iref.h	/^class SmartPtr$/;"	c
SockEventBase	NfUnit/baseEvent.cpp	/^SockEventBase::SockEventBase() : _sockType(BASE)$/;"	f	class:SockEventBase
SockEventBase	NfUnit/baseEvent.h	/^class SockEventBase : public EventBase$/;"	c
SpinLock	commonn/lock.h	/^        inline SpinLock() $/;"	f	class:SpinLock
SpinLock	commonn/lock.h	/^class SpinLock$/;"	c
Start	commonn/ThreadPool.cpp	/^void CWorkerThread::Start()$/;"	f	class:CWorkerThread
StartRoutine	commonn/ThreadPool.cpp	/^void* CWorkerThread::StartRoutine(void* arg)$/;"	f	class:CWorkerThread
SyncReactor	NfUnit/syncReactor.cpp	/^SyncReactor::SyncReactor() : _run(false),$/;"	f	class:SyncReactor
SyncReactor	NfUnit/syncReactor.h	/^class SyncReactor : public IReactor$/;"	c
TAR_DIR	Makefile	/^TAR_DIR := .\/$/;"	m
TAR_OBJ	Makefile	/^TAR_OBJ := lib_nf_svr.a$/;"	m
TCALLBACK	NfUnit/extreactor.cpp	/^void * EXTReactor::TCALLBACK(void *p)$/;"	f	class:EXTReactor
TCPCONNECT	NfUnit/baseEvent.h	/^        TCPCONNECT,$/;"	e	enum:SockEventBase::__anon14
THREAD	Makefile	/^THREAD := -lpthread$/;"	m
TIMEOUT	interface/ievent.h	/^            TIMEOUT     =      0x01,$/;"	e	enum:IEvent::__anon9
Test	testUnit/testSmartPtr/main.cpp	/^class Test : public IRef$/;"	c	file:
TestEvent	testUnit/testEXTReactor/main.cpp	/^          TestEvent() {};$/;"	f	class:TestEvent
TestEvent	testUnit/testEXTReactor/main.cpp	/^          TestEvent(int num) : label(num)  {};$/;"	f	class:TestEvent
TestEvent	testUnit/testEXTReactor/main.cpp	/^class TestEvent : public IEvent$/;"	c	file:
TestEvent	testUnit/testQueue/main.cpp	/^          TestEvent() {};$/;"	f	class:TestEvent
TestEvent	testUnit/testQueue/main.cpp	/^          TestEvent(int num) : label(num)  {};$/;"	f	class:TestEvent
TestEvent	testUnit/testQueue/main.cpp	/^class TestEvent : public IEvent$/;"	c	file:
TestEvent	testUnit/testSyncReactor/main.cpp	/^          TestEvent() {};$/;"	f	class:TestEvent
TestEvent	testUnit/testSyncReactor/main.cpp	/^          TestEvent(int num) : label(num)  {};$/;"	f	class:TestEvent
TestEvent	testUnit/testSyncReactor/main.cpp	/^class TestEvent : public EventBase$/;"	c	file:
ThreadExcute	event.h	/^    static void * ThreadExcute(Event * arg)$/;"	f	class:Event
ThreadManager	commonn/ThreadManager.h	/^        ThreadManager() {}$/;"	f	class:ThreadManager
ThreadManager	commonn/ThreadManager.h	/^class ThreadManager : private Uncopyable$/;"	c
Timer	commonn/timer.h	/^class Timer$/;"	c
UNDELETED	Buffer.h	/^static const bool UNDELETED = false;$/;"	v
Uncopyable	util.h	/^        Uncopyable() {}$/;"	f	class:Uncopyable
Uncopyable	util.h	/^class Uncopyable$/;"	c
Unlock	commonn/ThreadPool.h	/^	void Unlock() $/;"	f	class:CThreadNotify
WARN	commonn/asynLog.cpp	/^Log :: WARN(const char * fmt, ...)$/;"	f	class:Log
WORKER_PRIORITY	rapool.h	21;"	d
WORKER_PRIORITY	sapool.h	27;"	d
WRITE	NfUnit/baseEvent.h	/^        WRITE,$/;"	e	enum:SockEventBase::__anon14
Wait	commonn/ThreadPool.h	/^	void Wait() $/;"	f	class:CThreadNotify
WriteEvent	event.h	/^        explicit WriteEvent() : Event(),$/;"	f	class:WriteEvent
WriteEvent	event.h	/^        explicit WriteEvent(int len) : Event(),$/;"	f	class:WriteEvent
WriteEvent	event.h	/^class WriteEvent : public Event$/;"	c
_ASYN_LOG_	commonn/asynLog.h	13;"	d
_BUFFER_	Buffer.h	2;"	d
_CONFIG_PARSER_H	commonn/configParser.h	14;"	d
_EQUEUE_H_	NfUnit/eventqueue.h	2;"	d
_EVENTBASE_H_	NfUnit/baseEvent.h	2;"	d
_EVENT_	event.h	2;"	d
_EXTREACTOR_H_	NfUnit/extreactor.h	2;"	d
_IEQUEUE_H_	interface/iequeue.h	3;"	d
_IEVENT_H_	interface/ievent.h	3;"	d
_IREACTOR_H_	interface/ireactor.h	3;"	d
_IREF_H_	interface/iref.h	2;"	d
_LIENEVENT_H_	NfUnit/lineEvent.h	2;"	d
_Lf_SERVER_H	lfpool.h	2;"	d
_MEM_CACHE_	commonn/memCache.h	13;"	d
_NFSERVER_CORE_H	nf_server_core.h	15;"	d
_NF_SERVER_H	nf_server.h	12;"	d
_PARSE_WORK_	nf_base_work.h	2;"	d
_QUEUE_H	commonn/queue.h	12;"	d
_REACTOR_	reactor.h	2;"	d
_SERVER_H	commonn/Server.h	9;"	d
_THREADMG_H_	commonn/ThreadManager.h	3;"	d
_THREAD_POOL_H_	commonn/ThreadPool.h	2;"	d
_TIMER_	commonn/timer.h	14;"	d
_UTIL_	util.h	2;"	d
__LOCK_H_	commonn/lock.h	2;"	d
__NET_H__	net.h	12;"	d
__RAPOOL_H_	rapool.h	14;"	d
__SAPOOL_H_	sapool.h	20;"	d
__SYNCREACTOR_H_	NfUnit/syncReactor.h	2;"	d
_cb	NfUnit/baseEvent.h	/^        work_handle _cb;$/;"	m	class:EventBase
_cbp	NfUnit/baseEvent.h	/^        void * _cbp;$/;"	m	class:EventBase
_check_timer	NfUnit/syncReactor.h	/^        int _check_timer;$/;"	m	class:SyncReactor
_cnt	NfUnit/baseEvent.h	/^        int _cnt;$/;"	m	class:SockEventBase
_cnt	NfUnit/baseEvent.h	/^        std::atomic<int> _cnt;$/;"	m	class:EventBase
_cond	NfUnit/eventqueue.h	/^        MCondition _cond;$/;"	m	class:BlockEQueue
_cond	commonn/lock.h	/^        pthread_cond_t _cond;$/;"	m	class:MCondition
_devided	NfUnit/baseEvent.h	/^        int _devided;$/;"	m	class:EventBase
_emptystop	NfUnit/extreactor.h	/^		bool _emptystop;$/;"	m	class:EXTReactor
_emptystop	NfUnit/syncReactor.h	/^        bool _emptystop;$/;"	m	class:SyncReactor
_epev	NfUnit/syncReactor.h	/^        struct epoll_event * _epev;$/;"	m	class:SyncReactor	typeref:struct:SyncReactor::epoll_event
_epfd	NfUnit/syncReactor.h	/^        int  _epfd;$/;"	m	class:SyncReactor
_events	NfUnit/baseEvent.h	/^        int _events;$/;"	m	class:EventBase
_events	NfUnit/syncReactor.h	/^        std::atomic<int>  _events;$/;"	m	class:SyncReactor
_extReactor	NfUnit/syncReactor.h	/^        IReactor * _extReactor;$/;"	m	class:SyncReactor
_fd	NfUnit/baseEvent.h	/^        int _fd;$/;"	m	class:EventBase
_initialized	commonn/singleton.h	/^        static bool _initialized;$/;"	m	class:Singleton
_initialized	commonn/singleton.h	/^bool Singleton<T>::_initialized = false;$/;"	m	class:Singleton
_instance	commonn/singleton.h	/^        static T * _instance;$/;"	m	class:Singleton
_instance	commonn/singleton.h	/^T * Singleton<T>::_instance = NULL;$/;"	m	class:Singleton
_lfpool_t	lfpool.h	/^typedef struct _lfpool_t $/;"	s
_lock	NfUnit/eventqueue.h	/^        MLock  _lock;$/;"	m	class:ELQueue
_lock	NfUnit/eventqueue.h	/^        MLock _lock;$/;"	m	class:BlockEQueue
_lock	NfUnit/extreactor.h	/^		MLock _lock;$/;"	m	class:EXTReactor
_lock	NfUnit/syncReactor.h	/^        MLock _lock;$/;"	m	class:SyncReactor
_lock	commonn/lock.h	/^        Lock & _lock;$/;"	m	class:AutoLock
_lock	commonn/lock.h	/^        pthread_mutex_t & _lock;$/;"	m	class:MCondition
_lock	commonn/lock.h	/^        pthread_mutex_t _lock;$/;"	m	class:MLock
_lock	commonn/lock.h	/^        pthread_spinlock_t _lock;$/;"	m	class:SpinLock
_lockQueue	testUnit/testQueue/main.cpp	/^ELQueue _lockQueue;$/;"	v
_maxEvents	NfUnit/syncReactor.h	/^        int  _maxEvents;$/;"	m	class:SyncReactor
_maxevs	NfUnit/extreactor.h	/^		int _maxevs;$/;"	m	class:EXTReactor
_next	NfUnit/baseEvent.h	/^        IEvent *_next;$/;"	m	class:EventBase
_nf_server_t	nf_server_core.h	/^struct _nf_server_t$/;"	s
_pre	NfUnit/baseEvent.h	/^        IEvent *_pre;$/;"	m	class:EventBase
_queue	NfUnit/eventqueue.h	/^        EQueue _queue;$/;"	m	class:BlockEQueue
_queue	NfUnit/eventqueue.h	/^        EQueue _queue;$/;"	m	class:ELQueue
_queue	NfUnit/extreactor.h	/^		IEQueue *_queue;$/;"	m	class:EXTReactor
_queue	NfUnit/syncReactor.h	/^        ELQueue _queue;$/;"	m	class:SyncReactor
_queue_t	commonn/queue.h	/^struct _queue_t$/;"	s
_rapool_sock_item_t	rapool.h	/^struct _rapool_sock_item_t$/;"	s
_rapool_t	rapool.h	/^typedef struct _rapool_t$/;"	s
_reactor	NfUnit/baseEvent.h	/^        IReactor *_reactor;$/;"	m	class:EventBase
_readBuffer	NfUnit/lineEvent.h	/^        Buffer       _readBuffer;$/;"	m	class:LineEvent
_read_done_callback	NfUnit/lineEvent.h	/^        LINE_READ_CALLBACK_T   _read_done_callback;$/;"	m	class:LineEvent
_rect	testUnit/testEXTReactor/main.cpp	/^        IReactor * _rect;$/;"	m	class:TestEvent	file:
_reused	NfUnit/baseEvent.h	/^        bool _reused;$/;"	m	class:EventBase
_rio_t	net.h	/^typedef struct _rio_t$/;"	s
_run	NfUnit/extreactor.h	/^		bool _run;$/;"	m	class:EXTReactor
_run	NfUnit/syncReactor.h	/^        bool _run;$/;"	m	class:SyncReactor
_singleton_h	commonn/singleton.h	13;"	d
_sockType	NfUnit/baseEvent.h	/^        int _sockType;$/;"	m	class:SockEventBase
_status	NfUnit/baseEvent.h	/^        int _status;$/;"	m	class:EventBase
_status	NfUnit/extreactor.h	/^		int _status;$/;"	m	class:EXTReactor
_status	NfUnit/syncReactor.h	/^        int  _status;$/;"	m	class:SyncReactor
_threadma	NfUnit/extreactor.h	/^		ThreadManager _threadma;$/;"	m	class:EXTReactor
_threadsnum	NfUnit/extreactor.h	/^		int _threadsnum;$/;"	m	class:EXTReactor
_tids	commonn/ThreadManager.h	/^        std::vector<pthread_t> _tids;$/;"	m	class:ThreadManager
_to	NfUnit/baseEvent.h	/^        int _to;$/;"	m	class:EventBase
_type	NfUnit/baseEvent.h	/^        int _type;$/;"	m	class:EventBase
_waits	commonn/lock.h	/^        size_t _waits;$/;"	m	class:MCondition
_writeBuffer	NfUnit/lineEvent.h	/^        Buffer       _writeBuffer;$/;"	m	class:LineEvent
_write_done_callback	NfUnit/lineEvent.h	/^        LINE_WRITE_CALLBACK_T  _write_done_callback;$/;"	m	class:LineEvent
accept_callback	NfUnit/lineEvent.h	/^        virtual void accept_callback() {return;}$/;"	f	class:LineEvent
addRef	NfUnit/baseEvent.h	/^        virtual int addRef() {  return ++_cnt; }$/;"	f	class:EventBase
addRef	testUnit/testEXTReactor/main.cpp	/^          int addRef()$/;"	f	class:TestEvent
addRef	testUnit/testQueue/main.cpp	/^          int addRef() {return 0;}$/;"	f	class:TestEvent
addRef	testUnit/testSmartPtr/main.cpp	/^        int addRef()$/;"	f	class:Test
add_buffer	event.h	/^    inline int add_buffer(void * tmp,$/;"	f	class:ReadEvent
add_buffer	event.h	/^    inline int add_buffer(void * tmp,$/;"	f	class:WriteEvent
add_data	Buffer.cpp	/^int Buffer :: add_data(void * tmp,$/;"	f	class:Buffer
add_ev_flags	event.h	/^    inline void add_ev_flags(int flg)$/;"	f	class:Event
add_event	reactor.cpp	/^int Reactor :: add_event(Event * ev,$/;"	f	class:Reactor
add_handl_num	Buffer.cpp	/^int Buffer :: add_handl_num(int handled)$/;"	f	class:Buffer
add_prefix	commonn/asynLog.cpp	/^add_prefix(char * dest, const string &add)$/;"	f
add_timer_ms	commonn/timer.cpp	/^Timer :: add_timer_ms(long long time, $/;"	f	class:Timer
add_unhandle_num	Buffer.h	/^        inline void add_unhandle_num(int size)$/;"	f	class:Buffer
addr	rapool.h	/^    struct sockaddr_in addr;$/;"	m	struct:_rapool_sock_item_t	typeref:struct:_rapool_sock_item_t::sockaddr_in
allo_len	Buffer.h	/^        int allo_len;$/;"	m	class:Buffer
allocate	commonn/memCache.cpp	/^Allocate :: allocate(size_t n)$/;"	f	class:Allocate
array	commonn/queue.h	/^    int *array;$/;"	m	struct:_queue_t
backlog	nf_server_core.h	/^    size_t backlog;$/;"	m	struct:_nf_server_t
begin	NfUnit/eventqueue.h	/^        IEvent * begin;$/;"	m	class:EQueue
buff_size	reactor.h	/^    int buff_size;$/;"	m	struct:threadParas
buffer	commonn/asynLog.cpp	/^char Log :: buffer[LOG_MAXLINE];$/;"	m	class:Log	file:
buffer	commonn/asynLog.h	/^    static char buffer[LOG_MAXLINE];$/;"	m	class:Log
cache	Buffer.h	/^        void * cache;$/;"	m	class:Buffer
cache	event.h	/^        Buffer  cache;$/;"	m	class:WriteEvent
cache	event.h	/^        Buffer cache;$/;"	m	class:ReadEvent
cache	net.h	/^    char * cache;$/;"	m	struct:_rio_t
cache_len	net.h	/^    int cache_len;$/;"	m	struct:_rio_t
call_back_timeout	rapool.cpp	/^RaServer :: call_back_timeout(void * param)$/;"	f	class:RaServer
callback	NfUnit/extreactor.cpp	/^void EXTReactor::callback()$/;"	f	class:EXTReactor
callback	NfUnit/syncReactor.cpp	/^int SyncReactor::callback()$/;"	f	class:SyncReactor
cancel	NfUnit/extreactor.cpp	/^int EXTReactor::cancel(IEvent *ev)$/;"	f	class:EXTReactor
cancel	NfUnit/syncReactor.cpp	/^int SyncReactor::cancel(IEvent *ev)$/;"	f	class:SyncReactor
cap	NfUnit/eventqueue.h	/^        int cap;$/;"	m	class:EQueue
cap	commonn/queue.h	/^    int cap;$/;"	m	struct:_queue_t
cb_t	commonn/ThreadManager.h	/^    typedef void * (* cb_t)(void *);$/;"	t	class:ThreadManager
check_empty_space	Buffer.cpp	/^int Buffer :: check_empty_space()$/;"	f	class:Buffer
check_interval	rapool.h	/^    int check_interval;    \/\/微妙级别支持超时$/;"	m	struct:_rapool_t
clear	Buffer.cpp	/^void Buffer :: clear()$/;"	f	class:Buffer
clear	NfUnit/baseEvent.cpp	/^int SockEventBase::clear()$/;"	f	class:SockEventBase
clear	NfUnit/eventqueue.h	/^        void clear() $/;"	f	class:BlockEQueue
clear	NfUnit/eventqueue.h	/^        void clear() $/;"	f	class:ELQueue
clear	NfUnit/eventqueue.h	/^        void clear() $/;"	f	class:EQueue
cli_data	nf_server_core.h	/^        nf_server_cli_t * cli_data;$/;"	m	class:NfReactor
client_data	commonn/memCache.h	/^        char client_data[1];$/;"	m	union:Allocate::obj
cnt	interface/iref.h	/^        std::atomic<int> cnt;$/;"	m	class:IRef
connect_to	nf_server_core.h	/^    size_t connect_to;$/;"	m	struct:_nf_server_t
connect_type	nf_server_core.h	/^    size_t connect_type; $/;"	m	struct:_nf_server_t
consume	testUnit/testQueue/main.cpp	/^void * consume(void * param)$/;"	f
create	NfUnit/syncReactor.cpp	/^int SyncReactor::create()$/;"	f	class:SyncReactor
createData	test/case/getline/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
createData	test/case/getn/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
createData	test/client_simple.cpp	/^int createData(char * tmp, int off)$/;"	f
create_key_once	commonn/ThreadPool.cpp	/^create_key_once(void)$/;"	f
create_q	commonn/queue.cpp	/^int create_q(queue_t *q, int qcap)$/;"	f
create_svr	factory.h	/^    NfServer * create_svr()$/;"	f	class:Factory
ctime	commonn/asynLog.cpp	/^ctime(char * t_time, size_t n)$/;"	f
deallocate	commonn/memCache.cpp	/^Allocate :: deallocate(void * p, size_t n)$/;"	f	class:Allocate
default_hand	net.cpp	/^default_hand(int sig)$/;"	f
default_handle	test/server_simple.cpp	/^default_handle()$/;"	f
delRef	NfUnit/baseEvent.h	/^        virtual int delRef() { return  --_cnt; }$/;"	f	class:EventBase
delRef	testUnit/testEXTReactor/main.cpp	/^          int delRef()$/;"	f	class:TestEvent
delRef	testUnit/testQueue/main.cpp	/^          int delRef() {return 0;}$/;"	f	class:TestEvent
delRef	testUnit/testSmartPtr/main.cpp	/^        int delRef()$/;"	f	class:Test
del_ev_flags	event.h	/^    inline void del_ev_flags(int flg)$/;"	f	class:Event
del_event	reactor.cpp	/^int Reactor :: del_event(Event * ev)$/;"	f	class:Reactor
del_timer_ms	commonn/timer.cpp	/^Timer :: del_timer_ms(long long time, const void * const param)$/;"	f	class:Timer
derived	NfUnit/baseEvent.h	/^        virtual int derived() { return _devided;}$/;"	f	class:EventBase
derived	testUnit/testEXTReactor/main.cpp	/^          int derived() {return 0;}$/;"	f	class:TestEvent
derived	testUnit/testQueue/main.cpp	/^          int derived() {return 0;}$/;"	f	class:TestEvent
destroy	NfUnit/syncReactor.cpp	/^void SyncReactor::destroy()$/;"	f	class:SyncReactor
destroy	commonn/singleton.h	/^        static void destroy()$/;"	f	class:Singleton
destroyPtr	interface/iref.h	/^        void destroyPtr() $/;"	f	class:SmartPtr
destroy_q	commonn/queue.cpp	/^int destroy_q(queue_t *q)$/;"	f
empty	NfUnit/eventqueue.h	/^        bool empty() const { return _queue.empty();}$/;"	f	class:BlockEQueue
empty	NfUnit/eventqueue.h	/^        bool empty() const { return _queue.empty();}$/;"	f	class:ELQueue
empty	NfUnit/eventqueue.h	/^        bool empty() const { return begin == 0;}$/;"	f	class:EQueue
empty_q	commonn/queue.cpp	/^int empty_q(queue_t *q)$/;"	f
empty_str	commonn/configParser.cpp	/^static const std::string empty_str = "";$/;"	v	file:
end	NfUnit/eventqueue.h	/^        IEvent * end;$/;"	m	class:EQueue
end_idx	Buffer.h	/^        int end_idx;$/;"	m	class:Buffer
ep_events	rapool.h	/^    struct epoll_event * ep_events;$/;"	m	struct:_rapool_t	typeref:struct:_rapool_t::epoll_event
epfd	rapool.h	/^    int epfd;$/;"	m	struct:_rapool_t
epfd	reactor.h	/^        int epfd;$/;"	m	class:Reactor
epollAdd	NfUnit/syncReactor.cpp	/^int SyncReactor::epollAdd(IEvent * ev)$/;"	f	class:SyncReactor
epollDispatch	NfUnit/syncReactor.cpp	/^int SyncReactor::epollDispatch()$/;"	f	class:SyncReactor
epoll_active_event	reactor.cpp	/^int Reactor :: epoll_active_event(Event * ev) const$/;"	f	class:Reactor
epoll_add_event	reactor.cpp	/^int Reactor :: epoll_add_event(Event * ev)$/;"	f	class:Reactor
epoll_del_event	reactor.cpp	/^int Reactor :: epoll_del_event(Event * ev)$/;"	f	class:Reactor
epoll_dispatch	reactor.cpp	/^int Reactor :: epoll_dispatch(struct timeval * tv)$/;"	f	class:Reactor
epoll_unactive_event	reactor.cpp	/^int Reactor :: epoll_unactive_event(Event * ev) const$/;"	f	class:Reactor
erase	NfUnit/eventqueue.cpp	/^void EQueue::erase(IEvent * ev) $/;"	f	class:EQueue
erase	NfUnit/eventqueue.h	/^        void erase(IEvent * ev)$/;"	f	class:BlockEQueue
erase	NfUnit/eventqueue.h	/^        void erase(IEvent * ev)$/;"	f	class:ELQueue
ev_active	event.h	/^        int ev_active;$/;"	m	class:Event
ev_callback	event.h	/^        ev_handle ev_callback;$/;"	m	class:Event
ev_events	event.h	/^        short ev_events;$/;"	m	class:Event
ev_fd	event.h	/^        int ev_fd;$/;"	m	class:Event
ev_flags	event.h	/^        int ev_flags;$/;"	m	class:Event
ev_handle	event.h	/^typedef int (*ev_handle)(int, short, void *);$/;"	t
ev_list	reactor.h	/^        list<Event *> ev_list;$/;"	m	class:Reactor
ev_parse	event.h	/^        NonBlockFun * ev_parse;$/;"	m	class:ReadEvent
ev_parse	event.h	/^        NonBlockFun * ev_parse;$/;"	m	class:WriteEvent
ev_pos	event.h	/^        list<Event *>::iterator ev_pos;$/;"	m	class:Event
ev_reactor	event.h	/^        Reactor * ev_reactor;$/;"	m	class:Event
ev_task	event.h	/^        Event * ev_task; $/;"	m	class:EventTask
event	interface/iref.h	/^        T * event;$/;"	m	class:SmartPtr
event_count	reactor.h	/^        int event_count;$/;"	m	class:Reactor
event_count_ac	reactor.h	/^        int event_count_ac;$/;"	m	class:Reactor
event_mutex	reactor.h	/^    pthread_mutex_t event_mutex; $/;"	m	class:Reactor
event_queue_insert	reactor.cpp	/^void Reactor :: event_queue_insert(Event *ev,$/;"	f	class:Reactor
event_queue_remove	reactor.cpp	/^void Reactor :: event_queue_remove(Event *ev,$/;"	f	class:Reactor
events	reactor.h	/^        struct epoll_event *events;$/;"	m	class:Reactor	typeref:struct:Reactor::epoll_event
evepoll	reactor.h	/^struct evepoll$/;"	s
evread	reactor.h	/^    Event * evread;$/;"	m	struct:evepoll
evwrite	reactor.h	/^    Event * evwrite;$/;"	m	struct:evepoll
excute	event.cpp	/^void Event :: excute()$/;"	f	class:Event
excute_fun	event.cpp	/^int Event :: excute_fun()$/;"	f	class:Event
excute_fun	event.cpp	/^int ListenEvent :: excute_fun()$/;"	f	class:ListenEvent
excute_fun	event.cpp	/^int ReadEvent :: excute_fun()$/;"	f	class:ReadEvent
excute_fun	event.cpp	/^int WriteEvent :: excute_fun()$/;"	f	class:WriteEvent
expire_timer_ms	commonn/timer.cpp	/^Timer :: expire_timer_ms()$/;"	f	class:Timer
extEvent	interface/icore.cpp	/^int IReactor::extEvent(IEvent * ev)$/;"	f	class:IReactor
extfun	NfUnit/extreactor.cpp	/^void EXTReactor::extfun()$/;"	f	class:EXTReactor
fds	reactor.h	/^        struct evepoll * fds;$/;"	m	class:Reactor	typeref:struct:Reactor::evepoll
find_line	net.cpp	/^find_line(char * req, int end, char label)$/;"	f
fp	commonn/asynLog.cpp	/^FILE * Log :: fp; $/;"	m	class:Log	file:
fp	commonn/asynLog.h	/^    static FILE * fp; $/;"	m	class:Log
free_list	commonn/memCache.cpp	/^Allocate :: obj * Allocate :: free_list[LISTS] = $/;"	m	class:Allocate	file:
free_list	commonn/memCache.h	/^    static obj * free_list[LISTS];$/;"	m	class:Allocate
free_list_link	commonn/memCache.h	/^        union obj * free_list_link;$/;"	m	union:Allocate::obj	typeref:union:Allocate::obj::obj
fresh_cache	Buffer.cpp	/^int Buffer :: fresh_cache(int len)$/;"	f	class:Buffer
front	commonn/queue.h	/^    int front;$/;"	m	struct:_queue_t
full	NfUnit/eventqueue.h	/^        bool full() const { return _queue.full();}$/;"	f	class:BlockEQueue
full	NfUnit/eventqueue.h	/^        bool full() const { return _queue.full();}$/;"	f	class:ELQueue
full	NfUnit/eventqueue.h	/^        bool full() const { return size() >= cap;}$/;"	f	class:EQueue
get	commonn/configParser.cpp	/^ConfigParser :: get(const std::string sectionName, const std::string keyName) const$/;"	f	class:ConfigParser
get	commonn/configParser.cpp	/^Section :: get(const std::string key) const$/;"	f	class:Section
getBegin	NfUnit/eventqueue.h	/^        inline IEvent * getBegin() { return _queue.getBegin();}$/;"	f	class:BlockEQueue
getBegin	NfUnit/eventqueue.h	/^        inline IEvent * getBegin() { return _queue.getBegin();}$/;"	f	class:ELQueue
getBegin	NfUnit/eventqueue.h	/^        inline IEvent * getBegin() { return begin; }$/;"	f	class:EQueue
getExtReactor	NfUnit/extreactor.cpp	/^IReactor * EXTReactor::getExtReactor() $/;"	f	class:EXTReactor
getExtReactor	NfUnit/syncReactor.cpp	/^IReactor * SyncReactor::getExtReactor() $/;"	f	class:SyncReactor
getRefCnt	NfUnit/baseEvent.h	/^        virtual int getRefCnt() { return _cnt;}$/;"	f	class:EventBase
getRefCnt	testUnit/testEXTReactor/main.cpp	/^          int getRefCnt()$/;"	f	class:TestEvent
getRefCnt	testUnit/testQueue/main.cpp	/^          int getRefCnt() {return 0;}$/;"	f	class:TestEvent
getRefCnt	testUnit/testSmartPtr/main.cpp	/^        int getRefCnt()$/;"	f	class:Test
get_buf_unhandle_cache	event.h	/^    inline void * get_buf_unhandle_cache()$/;"	f	class:ReadEvent
get_buf_unhandle_cache	event.h	/^    inline void * get_buf_unhandle_cache()$/;"	f	class:WriteEvent
get_buf_unhandle_num	event.h	/^    inline int get_buf_unhandle_num()$/;"	f	class:ReadEvent
get_buf_unhandle_num	event.h	/^    inline int get_buf_unhandle_num()$/;"	f	class:WriteEvent
get_buffer	event.h	/^    inline Buffer & get_buffer()$/;"	f	class:ReadEvent
get_buffer	event.h	/^    inline Buffer & get_buffer()$/;"	f	class:WriteEvent
get_cache	Buffer.h	/^        void * get_cache() const$/;"	f	class:Buffer
get_cli_data	nf_server_core.h	/^        nf_server_cli_t * get_cli_data()$/;"	f	class:NfReactor
get_empty_cache	Buffer.h	/^        inline void * get_empty_cache() const$/;"	f	class:Buffer
get_empty_size	Buffer.h	/^        inline int get_empty_size() const$/;"	f	class:Buffer
get_epfd	reactor.h	/^    inline int get_epfd()$/;"	f	class:Reactor
get_ev_active	event.h	/^    inline int get_ev_active()$/;"	f	class:Event
get_ev_count	reactor.h	/^    inline int get_ev_count()$/;"	f	class:Reactor
get_ev_events	event.h	/^    inline int get_ev_events()$/;"	f	class:Event
get_ev_fd	event.h	/^    inline int get_ev_fd()$/;"	f	class:Event
get_ev_flags	event.h	/^    inline int get_ev_flags()$/;"	f	class:Event
get_ev_handle	event.h	/^    inline ev_handle get_ev_handle()$/;"	f	class:Event
get_ev_pos	event.h	/^    inline list<Event *>::iterator get_ev_pos()$/;"	f	class:Event
get_fds	reactor.h	/^    inline evepoll * get_fds()$/;"	f	class:Reactor
get_fds	reactor.h	/^    inline evepoll * get_fds(int idx)$/;"	f	class:Reactor
get_file	commonn/asynLog.h	/^    static FILE * get_file()$/;"	f	class:Log
get_parse_handle	event.h	/^    inline NonBlockFun * get_parse_handle()$/;"	f	class:WriteEvent
get_pthread_data	commonn/ThreadPool.cpp	/^get_pthread_data()$/;"	f
get_reactor	event.h	/^    inline Reactor * get_reactor()$/;"	f	class:Event
get_read_buff	NfUnit/lineEvent.h	/^        inline Buffer & get_read_buff(){ return _readBuffer; }$/;"	f	class:LineEvent
get_server	nf_server_core.h	/^        nf_server_t * get_server()$/;"	f	class:NfReactor
get_server_data	nf_server.cpp	/^nf_server_t * NfServer :: get_server_data()$/;"	f	class:NfServer
get_tcp_sockaddr	net.cpp	/^get_tcp_sockaddr(char * addr, int * port, $/;"	f
get_time_msec	commonn/timer.cpp	/^Timer :: get_time_msec(const struct timeval * tv)$/;"	f	class:Timer
get_unhandle_cache	Buffer.h	/^        inline void * get_unhandle_cache() const$/;"	f	class:Buffer
get_unhandle_num	Buffer.h	/^        inline int get_unhandle_num() const$/;"	f	class:Buffer
get_write_buff	NfUnit/lineEvent.h	/^        inline Buffer & get_write_buff() { return _writeBuffer; }$/;"	f	class:LineEvent
handle	NfUnit/baseEvent.h	/^        virtual int handle() { return _fd; }$/;"	f	class:EventBase
handle	testUnit/testEXTReactor/main.cpp	/^          int handle() { return 0;}$/;"	f	class:TestEvent
handle	testUnit/testQueue/main.cpp	/^          int handle() { return 0;}$/;"	f	class:TestEvent
idx	commonn/ThreadPool.h	/^        int idx;$/;"	m	class:CTask
init	Buffer.cpp	/^void Buffer :: init(int size)$/;"	f	class:Buffer
init	commonn/ThreadPool.cpp	/^int CThreadPool::init(int worker_size, int buff_size)$/;"	f	class:CThreadPool
init	commonn/asynLog.cpp	/^Log :: init(const char * name)$/;"	f	class:Log
init	commonn/memCache.cpp	/^Allocate :: init()$/;"	f	class:Allocate
init	event.cpp	/^void ListenEvent :: init(nf_server_t * svr)$/;"	f	class:ListenEvent
init	event.cpp	/^void ReadEvent :: init(int fd,$/;"	f	class:ReadEvent
init	event.cpp	/^void WriteEvent :: init(int fd,$/;"	f	class:WriteEvent
init	event.h	/^    inline void init(int fd, $/;"	f	class:Event
init	nf_server.cpp	/^int NfServer :: init(const std::string & logPath)$/;"	f	class:NfServer
init	nf_server_core.cpp	/^int NfReactor :: init(int ssize, nf_server_t * svr)$/;"	f	class:NfReactor
init	reactor.cpp	/^int Reactor :: init(int files, $/;"	f	class:Reactor
initBuffer	NfUnit/lineEvent.cpp	/^void LineEvent::initBuffer(int size)$/;"	f	class:LineEvent
instance	commonn/singleton.h	/^        static T * instance()$/;"	f	class:Singleton
isEmpty	Buffer.h	/^        bool isEmpty()$/;"	f	class:Buffer
isError	NfUnit/baseEvent.h	/^        virtual bool isError() { return false;}$/;"	f	class:EventBase
isError	testUnit/testEXTReactor/main.cpp	/^          bool isError() {return true;}$/;"	f	class:TestEvent
isError	testUnit/testQueue/main.cpp	/^          bool isError() {return true;}$/;"	f	class:TestEvent
isReUsed	NfUnit/baseEvent.h	/^        virtual bool isReUsed() { return _reused; }$/;"	f	class:EventBase
isReUsed	testUnit/testEXTReactor/main.cpp	/^          bool isReUsed() {return true;}         $/;"	f	class:TestEvent
isReUsed	testUnit/testQueue/main.cpp	/^          bool isReUsed() {return true;}$/;"	f	class:TestEvent
is_empty_q	commonn/queue.cpp	/^int is_empty_q(queue_t *q)$/;"	f
is_full_q	commonn/queue.cpp	/^int is_full_q(queue_t *q)$/;"	f
items	commonn/configParser.h	/^        std::map<std::string, std::string> items;$/;"	m	class:Section
join	NfUnit/extreactor.cpp	/^int EXTReactor::join() $/;"	f	class:EXTReactor
join	NfUnit/syncReactor.cpp	/^int SyncReactor::join()$/;"	f	class:SyncReactor
join	commonn/ThreadManager.cpp	/^int ThreadManager::join()$/;"	f	class:ThreadManager
label	testUnit/testEXTReactor/main.cpp	/^          int label;$/;"	m	class:TestEvent	file:
label	testUnit/testQueue/main.cpp	/^          int label;$/;"	m	class:TestEvent	file:
label	testUnit/testSyncReactor/main.cpp	/^          int label;$/;"	m	class:TestEvent	file:
lf_pool	lfpool.h	/^        static lfpool_t * lf_pool;        $/;"	m	class:LfServer
lfpool_t	lfpool.h	/^} lfpool_t;$/;"	t	typeref:struct:_lfpool_t
list_mutex	reactor.h	/^    pthread_mutex_t list_mutex;$/;"	m	class:Reactor
listen_port	nf_server_core.h	/^    size_t listen_port;$/;"	m	struct:_nf_server_t
listen_prio	nf_server_core.h	/^    size_t listen_prio; $/;"	m	struct:_nf_server_t
load	NfUnit/extreactor.cpp	/^int EXTReactor::load(const Section &sec)$/;"	f	class:EXTReactor
load	NfUnit/syncReactor.cpp	/^int SyncReactor::load(const Section & sec)$/;"	f	class:SyncReactor
lock	commonn/lock.h	/^        inline int lock() $/;"	f	class:MLock
lock	commonn/lock.h	/^        inline int lock() $/;"	f	class:SpinLock
lock	commonn/singleton.h	/^        void lock()$/;"	f	class:MutexLock
lock	lfpool.h	/^    pthread_mutex_t lock;$/;"	m	struct:_lfpool_t
log_buffer	commonn/asynLog.cpp	/^queue<string> Log :: log_buffer;$/;"	m	class:Log	file:
log_buffer	commonn/asynLog.h	/^    static queue<string> log_buffer;   $/;"	m	class:Log
log_cond	commonn/asynLog.cpp	/^pthread_cond_t Log:: log_cond;$/;"	m	class:Log	file:
log_cond	commonn/asynLog.h	/^    static pthread_cond_t  log_cond;$/;"	m	class:Log
log_mutex	commonn/asynLog.cpp	/^pthread_mutex_t Log :: log_mutex;$/;"	m	class:Log	file:
log_mutex	commonn/asynLog.h	/^    static pthread_mutex_t log_mutex;$/;"	m	class:Log
mSections	commonn/configParser.h	/^    std::map<std::string, Section> mSections;$/;"	m	class:ConfigParser
m_cond	commonn/ThreadPool.h	/^	pthread_cond_t 		m_cond;$/;"	m	class:CThreadNotify
m_mutex	commonn/ThreadPool.h	/^	pthread_mutex_t 	m_mutex;$/;"	m	class:CThreadNotify
m_mutexattr	commonn/ThreadPool.h	/^	pthread_mutexattr_t	m_mutexattr;$/;"	m	class:CThreadNotify
m_task_cnt	commonn/ThreadPool.h	/^	    int		        m_task_cnt;$/;"	m	class:CWorkerThread
m_task_list	commonn/ThreadPool.h	/^	    list<CTask*>	m_task_list;$/;"	m	class:CWorkerThread
m_thread_id	commonn/ThreadPool.h	/^	    pthread_t		m_thread_id;$/;"	m	class:CWorkerThread
m_thread_idx	commonn/ThreadPool.h	/^	    int     		m_thread_idx;$/;"	m	class:CWorkerThread
m_thread_notify	commonn/ThreadPool.h	/^	    CThreadNotify	m_thread_notify;$/;"	m	class:CWorkerThread
m_work_buff	commonn/ThreadPool.h	/^        void *          m_work_buff;$/;"	m	class:CWorkerThread
m_work_len	commonn/ThreadPool.h	/^        int             m_work_len;$/;"	m	class:CWorkerThread
m_worker_list	commonn/ThreadPool.h	/^	    CWorkerThread* 	m_worker_list;$/;"	m	class:CThreadPool
m_worker_size	commonn/ThreadPool.h	/^	    int      		m_worker_size;$/;"	m	class:CThreadPool
main	rapool.h	/^    pthread_t main;$/;"	m	struct:_rapool_t
main	test/case/getline/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getline/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getn/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/case/getn/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/client_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	test/server_simple.cpp	/^int main(int argc, char *argv[])$/;"	f
main	testUnit/main.cpp	/^int main()$/;"	f
main	testUnit/testEXTReactor/main.cpp	/^int main()$/;"	f
main	testUnit/testLineEvent/main.cpp	/^int main()$/;"	f
main	testUnit/testQueue/main.cpp	/^int main()$/;"	f
main	testUnit/testSmartPtr/main.cpp	/^int main()$/;"	f
main	testUnit/testSyncReactor/main.cpp	/^int main()$/;"	f
max	test/case/getline/client_simple.cpp	15;"	d	file:
max	test/case/getline/server_simple.cpp	14;"	d	file:
max	test/case/getn/client_simple.cpp	15;"	d	file:
max	test/case/getn/server_simple.cpp	14;"	d	file:
max	test/client_simple.cpp	15;"	d	file:
max	test/server_simple.cpp	14;"	d	file:
maxSize	NfUnit/eventqueue.h	/^        size_t maxSize() const { return _queue.maxSize();}$/;"	f	class:BlockEQueue
maxSize	NfUnit/eventqueue.h	/^        size_t maxSize() const { return _queue.maxSize();}$/;"	f	class:ELQueue
maxSize	NfUnit/eventqueue.h	/^        size_t maxSize() const { return cap;}$/;"	f	class:EQueue
mem_mutex	commonn/memCache.cpp	/^pthread_mutex_t Allocate :: mem_mutex[LISTS];$/;"	m	class:Allocate	file:
mem_mutex	commonn/memCache.h	/^    static pthread_mutex_t mem_mutex[LISTS];$/;"	m	class:Allocate
move_forward	net.cpp	/^move_forward(char * req, int start, int end)$/;"	f
mutex	commonn/singleton.h	/^        pthread_mutex_t mutex;$/;"	m	class:MutexLock
name	nf_server_core.h	/^    char name[256];$/;"	m	struct:_nf_server_t
need_join	nf_server_core.h	/^    size_t need_join;$/;"	m	struct:_nf_server_t
net_accept	net.cpp	/^net_accept(int sockfd, struct sockaddr *sa, socklen_t * addrlen)$/;"	f
net_connect_to_ms	net.cpp	/^net_connect_to_ms(int sockfd, struct sockaddr *sa, $/;"	f
net_connect_to_tv	net.cpp	/^net_connect_to_tv(int fd, struct sockaddr * sa, $/;"	f
net_ep_add	net.cpp	/^net_ep_add(int epfd, $/;"	f
net_ep_add_in	net.cpp	/^net_ep_add_in(int epfd, int fd)$/;"	f
net_ep_add_in1	net.cpp	/^net_ep_add_in1(int epfd, int fd)$/;"	f
net_ep_create	net.cpp	/^net_ep_create(int size)$/;"	f
net_ep_del	net.cpp	/^net_ep_del(int epfd, int fd)$/;"	f
net_tcplisten	net.cpp	/^net_tcplisten(int port, int queue)$/;"	f
nevents	reactor.h	/^        int nevents;$/;"	m	class:Reactor
nevents	testUnit/main.cpp	/^const int nevents = 10;$/;"	v
next	NfUnit/baseEvent.h	/^        virtual IEvent * next() { return _next; }$/;"	f	class:EventBase
next	testUnit/testEXTReactor/main.cpp	/^          IEvent * next() {return nextNode;}$/;"	f	class:TestEvent
next	testUnit/testQueue/main.cpp	/^          IEvent * next() {return nextNode;}$/;"	f	class:TestEvent
nextNode	testUnit/testEXTReactor/main.cpp	/^        IEvent * nextNode;$/;"	m	class:TestEvent	file:
nextNode	testUnit/testQueue/main.cpp	/^        IEvent * nextNode;$/;"	m	class:TestEvent	file:
next_check_time	rapool.h	/^    time_t next_check_time;$/;"	m	struct:_rapool_t
nf_server_bind	nf_server_core.cpp	/^int nf_server_bind(nf_server_t * sev)$/;"	f
nf_server_cli_t	nf_server_core.h	/^typedef struct sockaddr_in nf_server_cli_t;$/;"	t	typeref:struct:sockaddr_in
nf_server_create	nf_server.cpp	/^NfServer :: nf_server_create(const char * sev_name)$/;"	f	class:NfServer
nf_server_listen	nf_server_core.cpp	/^int nf_server_listen(nf_server_t * sev)$/;"	f
nf_server_t	event.h	/^typedef struct _nf_server_t nf_server_t;$/;"	t	typeref:struct:_nf_server_t
nf_server_t	nf_server_core.h	/^typedef struct _nf_server_t nf_server_t;$/;"	t	typeref:struct:_nf_server_t
nfile	reactor.h	/^        int nfile;$/;"	m	class:Reactor
num	reactor.h	/^    int num;$/;"	m	struct:threadParas
obj	commonn/memCache.h	/^    union obj$/;"	u	class:Allocate
operator &	interface/iref.h	/^        inline T * operator & () { return event; }$/;"	f	class:SmartPtr
operator *	interface/iref.h	/^        inline T & operator * () { return event; }$/;"	f	class:SmartPtr
operator ->	interface/iref.h	/^        inline T * operator -> () { return event; }$/;"	f	class:SmartPtr
operator =	Buffer.cpp	/^Buffer & Buffer :: operator=(const Buffer & rhs)$/;"	f	class:Buffer
operator =	interface/iref.h	/^        inline SmartPtr & operator = (SmartPtr &rhs)$/;"	f	class:SmartPtr
parseLine	nf_base_work.cpp	/^NonBlockReadLine * parseLine()$/;"	f
parse_handle	event.h	/^typedef int (*parse_handle)(int, void *);$/;"	t
parser_file	commonn/configParser.cpp	/^ConfigParser :: parser_file(const std::string &file)$/;"	f	class:ConfigParser
pause_event	reactor.cpp	/^int Reactor :: pause_event(Event * ev) const$/;"	f	class:Reactor
pkey	commonn/ThreadPool.cpp	/^static pthread_key_t pkey;$/;"	v	file:
ponce	commonn/ThreadPool.cpp	/^static pthread_once_t ponce = PTHREAD_ONCE_INIT; $/;"	v	file:
pool	reactor.h	/^        CThreadPool pool; $/;"	m	class:Reactor
poolPars	reactor.h	/^        struct threadParas poolPars;$/;"	m	class:Reactor	typeref:struct:Reactor::threadParas
pop	NfUnit/eventqueue.cpp	/^IEvent * BlockEQueue::pop()$/;"	f	class:BlockEQueue
pop	NfUnit/eventqueue.cpp	/^IEvent * EQueue::pop() $/;"	f	class:EQueue
pop	NfUnit/eventqueue.h	/^        IEvent * pop()$/;"	f	class:ELQueue
pop	interface/icore.cpp	/^IEvent * IEQueue :: pop()$/;"	f	class:IEQueue
pop_ms	NfUnit/eventqueue.h	/^        IEvent * pop_ms(int msec) { return 0;};$/;"	f	class:BlockEQueue
pop_ms	NfUnit/eventqueue.h	/^        IEvent * pop_ms(int msec) { return 0;};$/;"	f	class:ELQueue
pop_ms	NfUnit/eventqueue.h	/^        IEvent * pop_ms(int msec) { return 0;};$/;"	f	class:EQueue
pop_q	commonn/queue.cpp	/^int pop_q(queue_t *q, int *val)$/;"	f
pops	NfUnit/eventqueue.cpp	/^size_t BlockEQueue::pops(IEvent **ev, size_t items)$/;"	f	class:BlockEQueue
pops	NfUnit/eventqueue.cpp	/^size_t EQueue::pops(IEvent **ev, size_t items) $/;"	f	class:EQueue
pops	NfUnit/eventqueue.h	/^        size_t pops(IEvent **ev, size_t items)$/;"	f	class:ELQueue
pops	interface/icore.cpp	/^size_t IEQueue :: pops(IEvent ** ev, size_t items)$/;"	f	class:IEQueue
pops_ms	NfUnit/eventqueue.h	/^        size_t pops_ms(IEvent **ev, size_t items, int msec) { return 0;};$/;"	f	class:BlockEQueue
pops_ms	NfUnit/eventqueue.h	/^        size_t pops_ms(IEvent **ev, size_t items, int msec) { return 0;};$/;"	f	class:ELQueue
pops_ms	NfUnit/eventqueue.h	/^        size_t pops_ms(IEvent **ev, size_t items, int msec) { return 0;};$/;"	f	class:EQueue
post	NfUnit/extreactor.cpp	/^int EXTReactor::post(IEvent *ev)$/;"	f	class:EXTReactor
post	NfUnit/syncReactor.cpp	/^int SyncReactor::post(IEvent * ev)$/;"	f	class:SyncReactor
previous	NfUnit/baseEvent.h	/^        virtual IEvent *previous() { return _pre; }$/;"	f	class:EventBase
previous	testUnit/testEXTReactor/main.cpp	/^          IEvent * previous() {return previousNode;}$/;"	f	class:TestEvent
previous	testUnit/testQueue/main.cpp	/^          IEvent * previous() {return previousNode;}$/;"	f	class:TestEvent
previousNode	testUnit/testEXTReactor/main.cpp	/^        IEvent * previousNode;$/;"	m	class:TestEvent	file:
previousNode	testUnit/testQueue/main.cpp	/^        IEvent * previousNode;$/;"	m	class:TestEvent	file:
produce	testUnit/testQueue/main.cpp	/^void * produce(void * param)$/;"	f
produce_log	commonn/asynLog.cpp	/^Log :: produce_log(int event, const char * fmt, va_list args)$/;"	f	class:Log
pthread_key_del	commonn/ThreadPool.cpp	/^pthread_key_del(void)$/;"	f
push	NfUnit/eventqueue.cpp	/^size_t BlockEQueue::push(IEvent *ev)$/;"	f	class:BlockEQueue
push	NfUnit/eventqueue.h	/^        size_t push(IEvent *ev) $/;"	f	class:ELQueue
push	NfUnit/eventqueue.h	/^        size_t push(IEvent *ev) { return pushs(&ev, 1);}$/;"	f	class:EQueue
push	interface/icore.cpp	/^size_t IEQueue :: push(IEvent * ev)$/;"	f	class:IEQueue
push_ms	NfUnit/eventqueue.h	/^        size_t push_ms(IEvent *ev, int msec) { return 0;}$/;"	f	class:ELQueue
push_ms	NfUnit/eventqueue.h	/^        size_t push_ms(IEvent *ev, int msec) { return 0;}$/;"	f	class:EQueue
push_ms	NfUnit/eventqueue.h	/^        size_t push_ms(IEvent *ev, int msec) {return 0;}$/;"	f	class:BlockEQueue
push_ms	interface/icore.cpp	/^size_t IEQueue :: push_ms(IEvent * ev, int msec)$/;"	f	class:IEQueue
push_q	commonn/queue.cpp	/^int push_q(queue_t *q, int val)$/;"	f
pushs	NfUnit/eventqueue.cpp	/^size_t BlockEQueue::pushs(IEvent **ev, size_t items)$/;"	f	class:BlockEQueue
pushs	NfUnit/eventqueue.cpp	/^size_t EQueue::pushs(IEvent **ev, size_t items)$/;"	f	class:EQueue
pushs	NfUnit/eventqueue.h	/^        size_t pushs(IEvent **ev, size_t items)$/;"	f	class:ELQueue
pushs	interface/icore.cpp	/^size_t IEQueue :: pushs(IEvent ** ev, size_t items)$/;"	f	class:IEQueue
pushs_ms	NfUnit/eventqueue.h	/^        size_t pushs_ms(IEvent **ev, size_t items, int msec) { return 0;}$/;"	f	class:ELQueue
pushs_ms	NfUnit/eventqueue.h	/^        size_t pushs_ms(IEvent **ev, size_t items, int msec) { return 0;}$/;"	f	class:EQueue
pushs_ms	NfUnit/eventqueue.h	/^        size_t pushs_ms(IEvent **ev, size_t items, int msec){return 0;}$/;"	f	class:BlockEQueue
queue_t	commonn/queue.h	/^typedef struct _queue_t queue_t;$/;"	t	typeref:struct:_queue_t
ra_pool	rapool.h	/^       static rapool_t * ra_pool; $/;"	m	class:RaServer
rapool_add	rapool.cpp	/^RaServer :: rapool_add(nf_server_t * sev, int sock, struct sockaddr_in *addr)$/;"	f	class:RaServer
rapool_close_pool_sockets	rapool.cpp	/^RaServer :: rapool_close_pool_sockets(nf_server_t *sev, bool is_listenfd)$/;"	f	class:RaServer
rapool_del	rapool.cpp	/^RaServer :: rapool_del(nf_server_t *sev, int idx, int alive, bool remove)$/;"	f	class:RaServer
rapool_epoll_add_read	rapool.cpp	/^RaServer :: rapool_epoll_add_read(nf_server_t *sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_epoll_del	rapool.cpp	/^RaServer :: rapool_epoll_del(nf_server_t * sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_epoll_mod_read	rapool.cpp	/^RaServer :: rapool_epoll_mod_read(nf_server_t *sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_epoll_mod_write	rapool.cpp	/^RaServer :: rapool_epoll_mod_write(nf_server_t *sev, int idx, int work_reactor)$/;"	f	class:RaServer
rapool_main	rapool.cpp	/^RaServer :: rapool_main(void *param)$/;"	f	class:RaServer
rapool_produce	rapool.cpp	/^RaServer :: rapool_produce(nf_server_t * sev, $/;"	f	class:RaServer
rapool_reactor	rapool.cpp	/^RaServer :: rapool_reactor(rapool_t * pool, nf_server_pdata_t * pdata)$/;"	f	class:RaServer
rapool_sock_item_t	rapool.h	/^typedef struct _rapool_sock_item_t rapool_sock_item_t;$/;"	t	typeref:struct:_rapool_sock_item_t
rapool_t	rapool.h	/^typedef struct _rapool_t rapool_t;$/;"	t	typeref:struct:_rapool_t
rapool_t	rapool.h	/^}rapool_t;$/;"	t	typeref:struct:_rapool_t
rapool_workers	rapool.cpp	/^RaServer :: rapool_workers(void * param)$/;"	f	class:RaServer
reactor	NfUnit/baseEvent.h	/^        virtual IReactor *reactor() { return _reactor; }$/;"	f	class:EventBase
reactor	testUnit/testEXTReactor/main.cpp	/^          IReactor *reactor() {return _rect;}$/;"	f	class:TestEvent
reactor	testUnit/testQueue/main.cpp	/^          IReactor *reactor() {return NULL;}$/;"	f	class:TestEvent
reactor_num	nf_server_core.h	/^    size_t reactor_num;   \/\/reactor num$/;"	m	struct:_nf_server_t
read_callback	NfUnit/lineEvent.cpp	/^void LineEvent::read_callback()$/;"	f	class:LineEvent
read_done_callback	NfUnit/lineEvent.cpp	/^void LineEvent::read_done_callback()$/;"	f	class:LineEvent
read_handle	nf_server_core.h	/^    ev_handle read_handle;$/;"	m	struct:_nf_server_t
read_parse_handle	nf_server_core.h	/^    ParseFun * read_parse_handle;$/;"	m	struct:_nf_server_t
read_to	nf_server_core.h	/^    size_t read_to;$/;"	m	struct:_nf_server_t
readn	net.cpp	/^readn(int fd, void *usrbuf, size_t n)$/;"	f
readn_to_ms	net.cpp	/^readn_to_ms(int fd, void *ptr, size_t nbytes, int msecs)$/;"	f
rear	commonn/queue.h	/^    int rear;$/;"	m	struct:_queue_t
refill	commonn/memCache.cpp	/^Allocate :: refill(size_t n)$/;"	f	class:Allocate
registerAccept	NfUnit/baseEvent.cpp	/^int SockEventBase::registerAccept(int fd) $/;"	f	class:SockEventBase
registerBase	NfUnit/baseEvent.cpp	/^int SockEventBase::registerBase()$/;"	f	class:SockEventBase
registerRead	NfUnit/baseEvent.cpp	/^int SockEventBase::registerRead(int fd, size_t count)$/;"	f	class:SockEventBase
registerWrite	NfUnit/baseEvent.cpp	/^int SockEventBase::registerWrite(int fd, size_t count)$/;"	f	class:SockEventBase
release	NfUnit/baseEvent.cpp	/^bool EventBase::release()$/;"	f	class:EventBase
release	testUnit/testEXTReactor/main.cpp	/^          bool release()$/;"	f	class:TestEvent
release	testUnit/testQueue/main.cpp	/^          bool release() {return false;}$/;"	f	class:TestEvent
release	testUnit/testSmartPtr/main.cpp	/^        bool release()$/;"	f	class:Test
result	NfUnit/baseEvent.h	/^        virtual int result() { return _events; }$/;"	f	class:EventBase
result	testUnit/testEXTReactor/main.cpp	/^          int result() {return 0;}$/;"	f	class:TestEvent
result	testUnit/testQueue/main.cpp	/^          int result() {return 0;}$/;"	f	class:TestEvent
resume_event	reactor.cpp	/^int Reactor :: resume_event(Event * ev) const$/;"	f	class:Reactor
rio_bufptr	net.h	/^    char * rio_bufptr;\/\/ 建议直接读到线程工作靠占 $/;"	m	struct:_rio_t
rio_cnt	net.h	/^    int rio_cnt;      \/\/ 内置封装read时使用$/;"	m	struct:_rio_t
rio_fd	net.h	/^    int rio_fd;$/;"	m	struct:_rio_t
rio_init	net.cpp	/^void rio_init(rio_t *rp, int fd, int len)$/;"	f
rio_len	net.h	/^    size_t rio_len;   \/\/ 不建议使用封装read操作$/;"	m	struct:_rio_t
rio_ptr	net.h	/^    char * rio_ptr;   $/;"	m	struct:_rio_t
rio_read	net.cpp	/^rio_read(rio_t *rp, char *usrbuf, size_t n)$/;"	f	file:
rio_readline	net.cpp	/^rio_readline(rio_t *rp, void *usrbuf, size_t maxlen, int * st)$/;"	f
rio_readn	net.cpp	/^rio_readn(rio_t *rp, void *usrbuf, size_t n, int * st)$/;"	f
rio_t	net.h	/^} rio_t;$/;"	t	typeref:struct:_rio_t
rp	rapool.h	/^    rio_t rp;$/;"	m	struct:_rapool_sock_item_t
run	NfUnit/extreactor.cpp	/^int EXTReactor::run()$/;"	f	class:EXTReactor
run	NfUnit/syncReactor.cpp	/^int SyncReactor::run()$/;"	f	class:SyncReactor
run	commonn/ThreadManager.cpp	/^int ThreadManager::run(int pnum, cb_t cb, void *param) $/;"	f	class:ThreadManager
run	event.cpp	/^void EventTask :: run()$/;"	f	class:EventTask
run	nf_server.cpp	/^int NfServer :: run()$/;"	f	class:NfServer
run	nf_server_core.h	/^    int run;     $/;"	m	struct:_nf_server_t
run	rapool.h	/^    int * run;$/;"	m	struct:_rapool_t
run	reactor.h	/^        bool run;$/;"	m	class:Reactor
scan	commonn/configParser.cpp	/^ConfigParser :: scan() const$/;"	f	class:ConfigParser
scan	commonn/configParser.cpp	/^Section :: scan() const$/;"	f	class:Section
sendn	net.cpp	/^sendn(int fd, void *usrbuf, size_t n)$/;"	f
sendn_to_ms	net.cpp	/^sendn_to_ms(int fd, const void *ptr, size_t nbytes, int msecs)$/;"	f
server_type	nf_server_core.h	/^    size_t server_type;$/;"	m	struct:_nf_server_t
set	NfUnit/baseEvent.cpp	/^void EventBase::set(int hd, int evs, int type, work_handle cb, void *p)$/;"	f	class:EventBase
set	commonn/configParser.h	/^        inline void set(const std::string &key, const std::string &val)$/;"	f	class:Section
set	commonn/configParser.h	/^    inline void set(const std::string &sectionName, const std::string &keyName, $/;"	f	class:ConfigParser
setCallback	NfUnit/baseEvent.h	/^        virtual void setCallback(work_handle cb, void *p)$/;"	f	class:EventBase
setCallback	testUnit/testEXTReactor/main.cpp	/^          void setCallback(work_handle cb, void *p) {return;}$/;"	f	class:TestEvent
setCallback	testUnit/testQueue/main.cpp	/^          void setCallback(work_handle cb, void *p) {return;}$/;"	f	class:TestEvent
setDerived	NfUnit/baseEvent.h	/^        virtual void setDerived(int div) { _devided = div;}$/;"	f	class:EventBase
setDerived	testUnit/testEXTReactor/main.cpp	/^          void setDerived(int) {return;}$/;"	f	class:TestEvent
setDerived	testUnit/testQueue/main.cpp	/^          void setDerived(int) {return;}$/;"	f	class:TestEvent
setExtReactor	NfUnit/extreactor.cpp	/^IReactor * EXTReactor::setExtReactor(IReactor *) $/;"	f	class:EXTReactor
setExtReactor	NfUnit/syncReactor.cpp	/^IReactor * SyncReactor::setExtReactor(IReactor * rec) $/;"	f	class:SyncReactor
setHandle	NfUnit/baseEvent.h	/^        virtual void setHandle(int hd) { _fd = hd;}$/;"	f	class:EventBase
setHandle	testUnit/testEXTReactor/main.cpp	/^          void setHandle(int) {return;}$/;"	f	class:TestEvent
setHandle	testUnit/testQueue/main.cpp	/^          void setHandle(int) {return;}$/;"	f	class:TestEvent
setMaxEvents	NfUnit/extreactor.cpp	/^void EXTReactor::setMaxEvents(int num)$/;"	f	class:EXTReactor
setMaxEvents	NfUnit/syncReactor.cpp	/^void SyncReactor::setMaxEvents(int num)$/;"	f	class:SyncReactor
setMaxSize	NfUnit/eventqueue.h	/^        void setMaxSize(size_t maxsize) $/;"	f	class:BlockEQueue
setMaxSize	NfUnit/eventqueue.h	/^        void setMaxSize(size_t maxsize) $/;"	f	class:ELQueue
setMaxSize	NfUnit/eventqueue.h	/^        void setMaxSize(size_t maxsize) { cap = maxsize;}$/;"	f	class:EQueue
setNext	NfUnit/baseEvent.h	/^        virtual void setNext(IEvent *ev) { _next = ev; }$/;"	f	class:EventBase
setNext	testUnit/testEXTReactor/main.cpp	/^          void setNext(IEvent * node) {nextNode = node;}$/;"	f	class:TestEvent
setNext	testUnit/testQueue/main.cpp	/^          void setNext(IEvent * node) {nextNode = node;}$/;"	f	class:TestEvent
setPrevious	NfUnit/baseEvent.h	/^        virtual void setPrevious(IEvent *ev) { _pre = ev; }$/;"	f	class:EventBase
setPrevious	testUnit/testEXTReactor/main.cpp	/^          void setPrevious(IEvent * node) {previousNode = node;}$/;"	f	class:TestEvent
setPrevious	testUnit/testQueue/main.cpp	/^          void setPrevious(IEvent * node) {previousNode = node;}$/;"	f	class:TestEvent
setQueue	NfUnit/extreactor.cpp	/^int EXTReactor::setQueue(IEQueue * _q)$/;"	f	class:EXTReactor
setReUsed	NfUnit/baseEvent.h	/^        virtual void setReUsed(bool re) { _reused = re; }$/;"	f	class:EventBase
setReactor	NfUnit/baseEvent.h	/^        virtual void setReactor(IReactor *r) { _reactor = r; }$/;"	f	class:EventBase
setReactor	testUnit/testEXTReactor/main.cpp	/^          void setReactor(IReactor * rect) { _rect = rect;}$/;"	f	class:TestEvent
setReactor	testUnit/testQueue/main.cpp	/^          void setReactor(IReactor *) {return;}$/;"	f	class:TestEvent
setResult	NfUnit/baseEvent.h	/^        virtual void setResult(int evs) { _events = evs;}$/;"	f	class:EventBase
setResult	testUnit/testEXTReactor/main.cpp	/^          void setResult(int) {return;}$/;"	f	class:TestEvent
setResult	testUnit/testQueue/main.cpp	/^          void setResult(int) {return;}$/;"	f	class:TestEvent
setSockType	NfUnit/baseEvent.h	/^        void setSockType(int t) { _sockType = t;}$/;"	f	class:SockEventBase
setStatus	NfUnit/baseEvent.h	/^        virtual void setStatus(int s) { _status = s; }$/;"	f	class:EventBase
setStatus	testUnit/testEXTReactor/main.cpp	/^          void setStatus(int) {return;}$/;"	f	class:TestEvent
setStatus	testUnit/testQueue/main.cpp	/^          void setStatus(int) {return;}$/;"	f	class:TestEvent
setTaskIdx	commonn/ThreadPool.h	/^        void setTaskIdx(int num)$/;"	f	class:CTask
setThread	NfUnit/extreactor.cpp	/^void EXTReactor::setThread(int pnum)$/;"	f	class:EXTReactor
setThread	NfUnit/syncReactor.h	/^		void setThread(int pnum) { return;};$/;"	f	class:SyncReactor
setTimeout	NfUnit/baseEvent.h	/^        virtual void setTimeout(int msec) { _to = msec;} $/;"	f	class:EventBase
setTimeout	testUnit/testEXTReactor/main.cpp	/^          void setTimeout(int msec) {return;}$/;"	f	class:TestEvent
setTimeout	testUnit/testQueue/main.cpp	/^          void setTimeout(int msec) {return;}$/;"	f	class:TestEvent
setType	NfUnit/baseEvent.h	/^        virtual void setType(int t) { _type = t; }$/;"	f	class:EventBase
setType	testUnit/testEXTReactor/main.cpp	/^          void setType(int) { return;}$/;"	f	class:TestEvent
setType	testUnit/testQueue/main.cpp	/^          void setType(int) { return;}$/;"	f	class:TestEvent
set_clc_fd	net.cpp	/^set_clc_fd(int fd, int flags)$/;"	f
set_cli_data	nf_server_core.cpp	/^int NfReactor :: set_cli_data(int pos, nf_server_cli_t * addr)$/;"	f	class:NfReactor
set_ev_flags	event.h	/^    inline void set_ev_flags(int flg)$/;"	f	class:Event
set_event_active	reactor.h	/^    inline bool set_event_active(Event * ev)$/;"	f	class:Reactor
set_event_unactive	reactor.h	/^    inline bool set_event_unactive(Event * ev)$/;"	f	class:Reactor
set_fd	net.cpp	/^set_fd(int fd, int flags)$/;"	f
set_fd_block	net.cpp	/^set_fd_block(int fd)$/;"	f
set_fd_noblock	net.cpp	/^set_fd_noblock(int fd)$/;"	f
set_file	commonn/asynLog.h	/^    static void set_file(FILE * file)$/;"	f	class:Log
set_io_event_active	reactor.cpp	/^bool Reactor :: set_io_event_active(Event * ev)$/;"	f	class:Reactor
set_io_event_unactive	reactor.cpp	/^bool Reactor :: set_io_event_unactive(Event * ev)$/;"	f	class:Reactor
set_level	commonn/asynLog.h	/^    static void set_level(int level)$/;"	f	class:Log
set_linger	net.cpp	/^set_linger(int fd, int val)$/;"	f
set_parse_read_handle	nf_server.cpp	/^int NfServer :: set_parse_read_handle(ParseFun * read_handle)$/;"	f	class:NfServer
set_parse_write_handle	nf_server.cpp	/^int NfServer :: set_parse_write_handle(ParseFun * write_handle)$/;"	f	class:NfServer
set_pthread_data	commonn/ThreadPool.cpp	/^set_pthread_data(CWorkerThread * data)$/;"	f
set_read_done_callback	NfUnit/lineEvent.h	/^        inline void set_read_done_callback(LINE_READ_CALLBACK_T read_cb)$/;"	f	class:LineEvent
set_read_handle	nf_server.cpp	/^int NfServer :: set_read_handle(ev_handle read_handle)$/;"	f	class:NfServer
set_server_name	nf_server.cpp	/^int NfServer :: set_server_name(const char * sev_name)$/;"	f	class:NfServer
set_sev_socketopt	nf_server_core.cpp	/^int set_sev_socketopt(nf_server_t *sev, int fd)$/;"	f
set_status	commonn/asynLog.h	/^    static void set_status(int status)$/;"	f	class:Log
set_tcp_sockaddr	net.cpp	/^set_tcp_sockaddr(char * addr, int port, $/;"	f
set_write_done_callback	NfUnit/lineEvent.h	/^        inline void set_write_done_callback(LINE_WRITE_CALLBACK_T write_cb)$/;"	f	class:LineEvent
set_write_handle	nf_server.cpp	/^int NfServer :: set_write_handle(ev_handle write_handle)$/;"	f	class:NfServer
sev	event.h	/^        nf_server_t * sev;$/;"	m	class:ListenEvent
sev_data	nf_server.h	/^        nf_server_t *sev_data; \/\/server 核心数据结构$/;"	m	class:NfServer
sev_sock_id	rapool.h	/^    int sev_sock_id;$/;"	m	struct:_rapool_t
sev_socket	nf_server_core.h	/^    int sev_socket; $/;"	m	struct:_nf_server_t
signal	commonn/lock.h	/^        inline void signal() $/;"	f	class:MCondition
signalAll	commonn/lock.h	/^        inline void signalAll() $/;"	f	class:MCondition
size	NfUnit/eventqueue.h	/^        size_t size() const{ return _queue.size();}$/;"	f	class:BlockEQueue
size	NfUnit/eventqueue.h	/^        size_t size() const{ return _queue.size();}$/;"	f	class:ELQueue
size	NfUnit/eventqueue.h	/^        size_t size() const{ return used;}$/;"	f	class:EQueue
size	commonn/ThreadManager.h	/^        inline size_t size() { return _tids.size(); }$/;"	f	class:ThreadManager
size	commonn/queue.h	/^    int size;$/;"	m	struct:_queue_t
size	rapool.h	/^    int size;$/;"	m	struct:_rapool_t
sock	rapool.h	/^    int sock;$/;"	m	struct:_rapool_sock_item_t
sock_family	nf_server_core.h	/^    int sock_family;$/;"	m	struct:_nf_server_t
sock_timeout	rapool.h	/^    long long sock_timeout;    $/;"	m	struct:_rapool_sock_item_t
sockets	rapool.h	/^    rapool_sock_item_t * sockets;$/;"	m	struct:_rapool_t
socksize	nf_server_core.h	/^    size_t socksize;$/;"	m	struct:_nf_server_t
stack_size	nf_server_core.h	/^    size_t stack_size; \/\/线程栈大小$/;"	m	struct:_nf_server_t
start	reactor.cpp	/^int Reactor :: start()$/;"	f	class:Reactor
status	NfUnit/baseEvent.h	/^        virtual int status () { return _status;}$/;"	f	class:EventBase
status	NfUnit/extreactor.cpp	/^int EXTReactor::status() { return _status; }$/;"	f	class:EXTReactor
status	NfUnit/syncReactor.cpp	/^int SyncReactor::status() { return _status; }$/;"	f	class:SyncReactor
status	nf_server_core.h	/^    SERVER_STATUS_T status;$/;"	m	struct:_nf_server_t
status	rapool.h	/^    int status;$/;"	m	struct:_rapool_sock_item_t
status	reactor.h	/^        int status;$/;"	m	class:Reactor
status	reactor.h	/^    int status;$/;"	m	struct:evepoll
status	testUnit/testEXTReactor/main.cpp	/^          int status() {return 0;}$/;"	f	class:TestEvent
status	testUnit/testQueue/main.cpp	/^          int status() {return 0;}$/;"	f	class:TestEvent
stop	NfUnit/extreactor.cpp	/^int EXTReactor::stop()$/;"	f	class:EXTReactor
stop	NfUnit/syncReactor.cpp	/^int SyncReactor::stop()$/;"	f	class:SyncReactor
stop	commonn/asynLog.h	/^    static void stop()$/;"	f	class:Log
stopUntilEmpty	NfUnit/extreactor.cpp	/^int EXTReactor::stopUntilEmpty()$/;"	f	class:EXTReactor
stopUntilEmpty	NfUnit/syncReactor.cpp	/^int SyncReactor::stopUntilEmpty()$/;"	f	class:SyncReactor
str_idx	Buffer.h	/^        int str_idx;$/;"	m	class:Buffer
str_prefix	commonn/asynLog.cpp	/^const string Log :: str_prefix[4] = {"[DEBUG]   ", $/;"	m	class:Log	file:
str_prefix	commonn/asynLog.h	/^    static const string str_prefix[4];$/;"	m	class:Log
svr	factory.h	/^static struct NfServer * svr[] = $/;"	v	typeref:struct:NfServer
svr	nf_server_core.h	/^        nf_server_t * svr;$/;"	m	class:NfReactor
svr_destroy	rapool.cpp	/^RaServer :: svr_destroy()$/;"	f	class:RaServer
svr_init	sapool.cpp	/^SaServer :: svr_init()$/;"	f	class:SaServer
svr_join	rapool.cpp	/^RaServer :: svr_join()$/;"	f	class:RaServer
svr_listen	rapool.cpp	/^RaServer :: svr_listen()$/;"	f	class:RaServer
svr_pause	rapool.cpp	/^RaServer :: svr_pause()$/;"	f	class:RaServer
svr_reactor	nf_server_core.h	/^    NfReactor * svr_reactor;$/;"	m	struct:_nf_server_t
svr_resume	rapool.cpp	/^RaServer :: svr_resume()$/;"	f	class:RaServer
svr_run	rapool.cpp	/^RaServer :: svr_run()$/;"	f	class:RaServer
svr_run	sapool.cpp	/^SaServer :: svr_run()$/;"	f	class:SaServer
svr_set_stragy	rapool.cpp	/^RaServer :: svr_set_stragy(BaseWork * sta)$/;"	f	class:RaServer
svr_type	factory.h	/^        int svr_type;$/;"	m	class:Factory
swap	Buffer.cpp	/^void Buffer :: swap(Buffer &rhs)$/;"	f	class:Buffer
tcpconnect_callback	NfUnit/lineEvent.h	/^        virtual void tcpconnect_callback() {return;}$/;"	f	class:LineEvent
test	testUnit/testSmartPtr/main.cpp	/^void test(SmartPtr<Test> sptr)$/;"	f
test_read_fun	testUnit/main.cpp	/^int test_read_fun(int fd, short events, void * arg)$/;"	f
test_write_fun	testUnit/main.cpp	/^int test_write_fun(int fd, short events, void * arg)$/;"	f
threadParas	reactor.h	/^struct threadParas$/;"	s
thread_num	nf_server_core.h	/^    size_t thread_num;    \/\/每个reactor的thread num$/;"	m	struct:_nf_server_t
thread_usr_buf	nf_server_core.h	/^    size_t thread_usr_buf;$/;"	m	struct:_nf_server_t
timeout	NfUnit/baseEvent.h	/^        virtual timeval * timeout() {return NULL;}$/;"	f	class:EventBase
timeout	rapool.h	/^    int timeout;        \/\/epoll的超时时间$/;"	m	struct:_rapool_t
timeout	testUnit/testEXTReactor/main.cpp	/^          timeval * timeout() {return NULL;}$/;"	f	class:TestEvent
timeout	testUnit/testQueue/main.cpp	/^          timeval * timeout() {return NULL;}$/;"	f	class:TestEvent
timer	commonn/timer.h	/^        multimap<long long, pair<timer_callback_proc, void *> > timer;$/;"	m	class:Timer
timer_callback_proc	commonn/timer.h	/^        typedef int (* timer_callback_proc)(void * param);$/;"	t	class:Timer
top_timer_ms	commonn/timer.cpp	/^Timer :: top_timer_ms()$/;"	f	class:Timer
trylock	commonn/lock.h	/^        inline int trylock() $/;"	f	class:MLock
trylock	commonn/lock.h	/^        inline int trylock() $/;"	f	class:SpinLock
tstLabel	nf_base_work.cpp	/^static const char tstLabel = '\\n';$/;"	v	file:
type	NfUnit/baseEvent.h	/^        virtual int type() { return _type; }$/;"	f	class:EventBase
type	testUnit/testEXTReactor/main.cpp	/^          int type()  {return 0;}$/;"	f	class:TestEvent
type	testUnit/testQueue/main.cpp	/^          int type()  {return 0;}$/;"	f	class:TestEvent
unlock	commonn/lock.h	/^        inline int unlock() $/;"	f	class:MLock
unlock	commonn/lock.h	/^        inline int unlock() $/;"	f	class:SpinLock
unlock	commonn/singleton.h	/^        void unlock()$/;"	f	class:MutexLock
used	NfUnit/eventqueue.h	/^        int used;$/;"	m	class:EQueue
using_size	rapool.h	/^    long long using_size;$/;"	m	struct:_rapool_t
w_allo_cache	net.h	/^    char * w_allo_cache;$/;"	m	struct:_rio_t
w_allo_len	net.h	/^    int w_allo_len;    $/;"	m	struct:_rio_t
w_cache	net.h	/^    char * w_cache;$/;"	m	struct:_rio_t
w_cache_len	net.h	/^    int w_cache_len;$/;"	m	struct:_rio_t
wait	commonn/lock.h	/^        inline int wait(const timeval *tv) $/;"	f	class:MCondition
waits	commonn/lock.h	/^        inline size_t waits() { return _waits; }$/;"	f	class:MCondition
work	nf_base_work.cpp	/^int NonBlockReadLine :: work(int fd, $/;"	f	class:NonBlockReadLine
work	nf_base_work.cpp	/^int NonBlockWrite :: work(int fd, void * arg) $/;"	f	class:NonBlockWrite
work	test/case/getline/client_simple.cpp	/^void * work(void * arg)$/;"	f
work	test/case/getn/client_simple.cpp	/^void * work(void * arg)$/;"	f
work	test/client_simple.cpp	/^void * work(void * arg)$/;"	f
work_handle	interface/ievent.h	/^        typedef void (*work_handle)(IEvent *, void *);$/;"	t	class:IEvent
work_prio	nf_server_core.h	/^    size_t work_prio;$/;"	m	struct:_nf_server_t
writeData	nf_base_work.cpp	/^NonBlockWrite * writeData()$/;"	f
write_callback	NfUnit/lineEvent.cpp	/^void LineEvent::write_callback()$/;"	f	class:LineEvent
write_done_callback	NfUnit/lineEvent.cpp	/^void LineEvent::write_done_callback()$/;"	f	class:LineEvent
write_handle	nf_server_core.h	/^    ev_handle write_handle;$/;"	m	struct:_nf_server_t
write_log	commonn/asynLog.cpp	/^Log :: write_log(void *)$/;"	f	class:Log
write_parse_handle	nf_server_core.h	/^    ParseFun * write_parse_handle;$/;"	m	struct:_nf_server_t
write_to	nf_server_core.h	/^    size_t write_to;$/;"	m	struct:_nf_server_t
~AutoLock	commonn/lock.h	/^        inline ~AutoLock() $/;"	f	class:AutoLock
~BlockEQueue	NfUnit/eventqueue.cpp	/^BlockEQueue::~BlockEQueue()$/;"	f	class:BlockEQueue
~Buffer	Buffer.h	/^        virtual ~Buffer()$/;"	f	class:Buffer
~CTask	commonn/ThreadPool.h	/^        virtual ~CTask(){}$/;"	f	class:CTask
~CThreadNotify	commonn/ThreadPool.cpp	/^CThreadNotify :: ~CThreadNotify()$/;"	f	class:CThreadNotify
~CThreadPool	commonn/ThreadPool.cpp	/^CThreadPool::~CThreadPool()$/;"	f	class:CThreadPool
~CWorkerThread	commonn/ThreadPool.cpp	/^CWorkerThread::~CWorkerThread()$/;"	f	class:CWorkerThread
~ConfigParser	commonn/configParser.h	/^        virtual ~ConfigParser(){}$/;"	f	class:ConfigParser
~EQueue	NfUnit/eventqueue.h	/^        ~EQueue() $/;"	f	class:EQueue
~EXTReactor	NfUnit/extreactor.cpp	/^EXTReactor::~EXTReactor()$/;"	f	class:EXTReactor
~Event	event.h	/^    virtual ~Event(){};$/;"	f	class:Event
~EventBase	NfUnit/baseEvent.cpp	/^EventBase::~EventBase() $/;"	f	class:EventBase
~Factory	factory.h	/^        virtual ~Factory(){};$/;"	f	class:Factory
~IEQueue	interface/iequeue.h	/^        virtual ~IEQueue() {};$/;"	f	class:IEQueue
~IEvent	interface/ievent.h	/^        virtual ~IEvent() {};$/;"	f	class:IEvent
~IReactor	interface/ireactor.h	/^        virtual ~IReactor() {};$/;"	f	class:IReactor
~IRef	interface/iref.h	/^        virtual ~IRef(){}  $/;"	f	class:IRef
~LfServer	lfpool.h	/^        virtual ~LfServer(){};$/;"	f	class:LfServer
~LineEvent	NfUnit/lineEvent.h	/^        ~LineEvent() {};$/;"	f	class:LineEvent
~MCondition	commonn/lock.h	/^        ~MCondition() $/;"	f	class:MCondition
~MLock	commonn/lock.h	/^        inline ~MLock() $/;"	f	class:MLock
~MutexLock	commonn/singleton.h	/^        ~MutexLock()$/;"	f	class:MutexLock
~NfServer	nf_server.cpp	/^NfServer :: ~NfServer()$/;"	f	class:NfServer
~NonBlockFun	nf_base_work.h	/^        virtual ~NonBlockFun(){};$/;"	f	class:NonBlockFun
~NonBlockReadLine	nf_base_work.h	/^        virtual ~NonBlockReadLine(){}$/;"	f	class:NonBlockReadLine
~NonBlockWrite	nf_base_work.h	/^        virtual ~NonBlockWrite(){}$/;"	f	class:NonBlockWrite
~ParseFun	nf_base_work.h	/^        virtual ~ParseFun(){};$/;"	f	class:ParseFun
~RaServer	rapool.h	/^        virtual ~RaServer(){};$/;"	f	class:RaServer
~SaServer	sapool.h	/^        virtual ~SaServer(){};$/;"	f	class:SaServer
~Server	commonn/Server.h	/^        virtual ~Server(){};$/;"	f	class:Server
~SmartPtr	interface/iref.h	/^        ~SmartPtr() $/;"	f	class:SmartPtr
~SockEventBase	NfUnit/baseEvent.cpp	/^SockEventBase::~SockEventBase()$/;"	f	class:SockEventBase
~SpinLock	commonn/lock.h	/^        inline ~SpinLock() $/;"	f	class:SpinLock
~SyncReactor	NfUnit/syncReactor.cpp	/^SyncReactor::~SyncReactor()$/;"	f	class:SyncReactor
~TestEvent	testUnit/testEXTReactor/main.cpp	/^          ~TestEvent() {printf("clear\\n");}$/;"	f	class:TestEvent
~TestEvent	testUnit/testQueue/main.cpp	/^          ~TestEvent() {}$/;"	f	class:TestEvent
~TestEvent	testUnit/testSyncReactor/main.cpp	/^          ~TestEvent() {printf("clear\\n");}$/;"	f	class:TestEvent
~ThreadManager	commonn/ThreadManager.h	/^        ~ThreadManager() { this->join(); }$/;"	f	class:ThreadManager
~Uncopyable	util.h	/^        ~Uncopyable() {}$/;"	f	class:Uncopyable
